<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Zombie Tap Defense</title>
  <style>
    :root{
      --bg:#0b0d12;
      --panel:rgba(18,22,32,.86);
      --panel2:rgba(12,14,20,.78);
      --text:#e7eaf0;
      --muted:#9aa3b2;
      --accent:#8b5cf6;
      --good:#22c55e;
      --bad:#ef4444;
      --line:rgba(255,255,255,.08);
      --shadow:0 12px 30px rgba(0,0,0,.35);
      --hud-glow:0 8px 24px rgba(139,92,246,.25);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 50% -10%, rgba(139,92,246,.18), transparent 60%),
                  radial-gradient(900px 700px at 90% 20%, rgba(34,197,94,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-tap-highlight-color: transparent;
    }

    #root{
      position:fixed; inset:0;
      display:flex; flex-direction:column;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* HUD */
    #hud{
      position:absolute;
      left:0; right:0; top:0;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 10px calc(10px + env(safe-area-inset-top));
      background: linear-gradient(to bottom, rgba(10,12,18,.92), rgba(10,12,18,.55), transparent);
      pointer-events:none;
      z-index:10;
    }
    #hud .left, #hud .right{
      display:flex; align-items:center; gap:10px;
      pointer-events:none;
      flex-wrap:wrap;
    }
    #hud .pill, #hud .stat, #hud .divider, #hud .hpBar, #hud .hpWrap, #hud .hpText{pointer-events:none;}
    #hud .right{pointer-events:auto;}
    #hud button{pointer-events:auto;}
    .pill{
      background: linear-gradient(135deg, rgba(255,255,255,.05), rgba(255,255,255,.00));
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 10px;
      box-shadow: var(--shadow);
      display:flex; align-items:center; gap:10px;
      min-height:38px;
      backdrop-filter: blur(6px);
    }
    .stat{
      display:flex; flex-direction:column; line-height:1.05;
      gap:2px;
    }
    .stat .k{font-size:11px; color:var(--muted); display:flex; align-items:center; gap:6px; letter-spacing:.15px;}
    .stat .v{font-size:13px; font-weight:800; display:flex; align-items:center; gap:6px;}
    .coinBadge{
      position:relative;
      padding:6px 12px;
      border-radius:999px;
      background: linear-gradient(135deg, #facc15, #f59e0b);
      color:#1f2937;
      box-shadow: 0 6px 16px rgba(250,204,21,.35), inset 0 1px 0 rgba(255,255,255,.35);
      min-width:48px;
      justify-content:center;
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-weight:900;
      overflow:hidden;
    }
    .coinBadge::after{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(120deg, rgba(255,255,255,.22), transparent 40%, rgba(255,255,255,.10));
      pointer-events:none;
      mix-blend-mode:screen;
      opacity:0.8;
    }
    .coinBadge.pop{animation: bankPop 0.18s ease;}
    @keyframes bankPop{0%{transform:scale(1);}50%{transform:scale(1.08);}100%{transform:scale(1);}}
    .divider{width:1px; height:18px; background:var(--line)}
    .btn{
      pointer-events:auto;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{background: rgba(255,255,255,.09)}
    .btn:active{transform: translateY(1px) scale(.98)}
    .btn.iconBtn{
      width:44px; height:44px;
      border-radius:50%;
      padding:0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(255,255,255,.02));
    }
    .btn.toggleOn{box-shadow: 0 0 0 1px rgba(94,234,212,.45), 0 0 16px rgba(94,234,212,.35);}
    .btn.primary{
      background: linear-gradient(135deg, rgba(139,92,246,.85), rgba(139,92,246,.45));
      border-color: rgba(139,92,246,.55);
    }
    .btn.good{
      background: linear-gradient(135deg, rgba(34,197,94,.8), rgba(34,197,94,.35));
      border-color: rgba(34,197,94,.5);
    }
    .btn.bad{
      background: linear-gradient(135deg, rgba(239,68,68,.8), rgba(239,68,68,.35));
      border-color: rgba(239,68,68,.5);
    }
    .btn.small{padding:8px 10px; border-radius:999px; font-size:13px}

    /* Health bar */
    .hpWrap{display:flex; align-items:center; gap:10px; position:relative; padding-right:8px; box-shadow:var(--hud-glow)}
    .hpBar{
      width:200px; height:16px; border-radius:12px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.09);
      overflow:hidden;
      position:relative;
    }
    .hpWrap.regen .hpBar::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(120deg, rgba(34,197,94,.26), rgba(34,197,94,.05));
      animation: regenPulse 1s linear infinite;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    @keyframes regenPulse{from{transform: translateX(-12px);}to{transform: translateX(12px);}}
    .hpFill{
      height:100%;
      width:100%;
      background: linear-gradient(90deg, rgba(34,197,94,.95), rgba(34,197,94,.55));
      border-right:1px solid rgba(255,255,255,.18);
      transform-origin:left center;
      transition: background .2s linear;
    }
    .hpGhost{
      position:absolute; left:0; top:0; height:100%; width:100%;
      background: linear-gradient(90deg, rgba(255,255,255,.16), rgba(255,255,255,.05));
      pointer-events:none;
      transform-origin:left center;
    }
    .hpText{font-size:12px; color:var(--muted); font-weight:700}
    .waveMeta{display:flex; flex-direction:column; gap:4px;}
    .waveProg{width:200px; height:12px; border-radius:12px; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12); overflow:hidden; position:relative; box-shadow: inset 0 2px 6px rgba(0,0,0,.35);}
    .waveFill{position:absolute; left:0; top:0; height:100%; width:0%; background: linear-gradient(90deg, rgba(139,92,246,.95), rgba(94,234,212,.9)); box-shadow: 0 0 14px rgba(94,234,212,.45); border-right:1px solid rgba(255,255,255,.35);}
    .tag{font-size:11px; color:var(--muted); font-weight:800; letter-spacing:.5px; text-transform:uppercase;}
    .pauseBtn{padding:9px 10px; border-radius:12px; min-width:46px;}
    .comboHud{pointer-events:none; display:flex; align-items:center; gap:10px; min-width:150px;}
    .comboHud .v{font-size:20px; letter-spacing:0.3px;}
    .comboBar{position:relative; flex:1; height:10px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid var(--line); overflow:hidden;}
    .comboFill{position:absolute; inset:0; width:0%; background: linear-gradient(90deg, rgba(168,85,247,.9), rgba(94,234,212,.8)); box-shadow: 0 0 12px rgba(168,85,247,.4);}
    .comboHud.pop{animation: comboPop 0.16s ease;}
    @keyframes comboPop{0%{transform:scale(1);}50%{transform:scale(1.06);}100%{transform:scale(1);}}

    #bossBar{
      position:absolute;
      left:50%; top:62px;
      transform: translateX(-50%);
      display:flex; align-items:center; gap:10px;
      padding:7px 12px;
      background: rgba(18,22,32,.85);
      border:1px solid var(--line);
      border-radius:12px;
      box-shadow: var(--shadow);
      pointer-events:none;
      z-index:9;
    }
    #bossBar.hidden{display:none;}
    .bossLabel{font-size:12px; font-weight:900; color:#f87171; letter-spacing:1px;}
    .bossHp{width:200px; height:12px; border-radius:10px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14); overflow:hidden; position:relative;}
    .bossHpFill{position:absolute; left:0; top:0; height:100%; width:100%; background: linear-gradient(90deg, rgba(248,113,113,.9), rgba(248,113,113,.55)); transform-origin:left center;}
    .bossHpText{font-size:12px; color:var(--muted); font-weight:800;}

    /* Canvas */
    #gameCanvas{
      width:100%;
      height:100%;
      display:block;
      touch-action:none; /* important: pointer events without scroll/zoom */
      user-select:none;
      -webkit-user-select:none;
      background: radial-gradient(900px 700px at 50% 15%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(1000px 750px at 50% 110%, rgba(139,92,246,.08), transparent 60%);
    }

    /* Overlays */
    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
      z-index:30;
      background: radial-gradient(900px 650px at 50% 30%, rgba(0,0,0,.55), rgba(0,0,0,.72));
      backdrop-filter: blur(6px);
    }
    .hidden{display:none !important}
    .card{
      width:min(520px, 100%);
      background: rgba(14,16,24,.78);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      box-shadow: 0 22px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .card header{
      padding:16px 16px 10px 16px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
    }
    .title{
      font-size:20px; font-weight:900; margin:0 0 6px 0;
      letter-spacing:.2px;
    }
    .subtitle{margin:0; color:var(--muted); font-size:13px; line-height:1.35}
    .card .content{padding:14px 16px 16px 16px}
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.04);
      border-radius:14px;
    }
    .row .meta{display:flex; flex-direction:column; gap:3px}
    .row .meta .name{font-weight:900}
    .row .meta .desc{font-size:12px; color:var(--muted)}
    .price{font-size:12px; color:var(--muted); font-weight:800}
    .footerActions{
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      margin-top:12px;
    }
    .tiny{
      font-size:12px; color:var(--muted); line-height:1.35;
    }
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      font-weight:800;
      font-size:11px;
      color:rgba(255,255,255,.85);
    }

    /* Small toast */
    #toast{
      position:absolute;
      left:50%; bottom:18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 12px;
      font-weight:800;
      font-size:13px;
      color:rgba(255,255,255,.92);
      box-shadow: 0 12px 28px rgba(0,0,0,.45);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      z-index:40;
    }
    #toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }

    /* Vignette + vignette pulse */
    #vignette{
      position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(120% 95% at 50% 50%, rgba(0,0,0,0), rgba(0,0,0,.55));
      opacity:0; transition: opacity .25s ease;
      z-index:8;
    }

    /* Settings panel */
    #settingsOverlay{position:fixed; inset:0; display:none; align-items:flex-start; justify-content:flex-end; padding:14px; z-index:40; background:rgba(0,0,0,.45); backdrop-filter: blur(4px);}
    #settingsOverlay.show{display:flex;}
    #settingsOverlay .backdrop{position:absolute; inset:0;}
    #settingsPanel{
      position:relative;
      background: var(--panel2);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 12px 10px 12px;
      box-shadow: var(--shadow);
      min-width:220px;
      z-index:1;
      pointer-events:auto;
    }
    #settingsPanel header{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px;}
    #settingsPanel h3{margin:0; font-size:16px; letter-spacing:.2px;}
    #settingsPanel .closeSettings{min-height:44px; padding:6px 12px; border-radius:12px; border:1px solid var(--line); background:rgba(255,255,255,.06); color:var(--text); cursor:pointer; font-weight:800;}
    #settingsPanel .closeSettings:active{transform: scale(.98);}
    .settingRow{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0; font-size:13px;}
    .settingRow label{color:var(--muted); font-weight:700;}
    .toggle{width:42px; height:22px; border-radius:999px; background:rgba(255,255,255,.16); border:1px solid var(--line); position:relative; cursor:pointer;}
    .toggle .dot{position:absolute; width:18px; height:18px; border-radius:50%; background:#fff; top:1px; left:1px; transition: transform .18s ease;}
    .toggle.on{background:rgba(139,92,246,.55); border-color:rgba(139,92,246,.6);} 
    .toggle.on .dot{transform: translateX(20px);}
  </style>
</head>
<body>
    <div id="root">
    <div id="vignette"></div>
      <canvas id="gameCanvas"></canvas>

    <div id="hud">
      <div class="left">
        <div class="pill hpWrap">
          <div class="stat">
            <div class="k">Health</div>
            <div class="v" id="hpLabel">100</div>
          </div>
          <div class="hpBar" aria-label="Health bar">
            <div class="hpFill" id="hpFill"></div>
            <div class="hpGhost" id="hpGhost"></div>
          </div>
          <div class="hpText" id="hpPct">100%</div>
        </div>

        <div class="pill bankPill">
          <div class="stat">
            <div class="k">üí∞ Bank</div>
            <div class="v"><span class="coinBadge" id="coinLabel">0</span></div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Wave</div>
            <div class="v" id="waveLabel">0</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Score</div>
            <div class="v" id="scoreLabel">0</div>
          </div>
        </div>

        <div class="pill">
          <div class="waveMeta">
            <div class="stat">
              <div class="k">üìà Wave Progress</div>
              <div class="v" id="waveProgressLabel">0/0</div>
            </div>
            <div class="waveProg" aria-label="Wave progress">
              <div class="waveFill" id="waveFill"></div>
            </div>
          </div>
        </div>

        <div class="pill comboHud" id="comboHud">
          <div class="stat">
            <div class="k">Combo</div>
            <div class="v" id="comboValue">‚Äî</div>
          </div>
          <div class="comboBar" aria-label="Combo timer">
            <div class="comboFill" id="comboFill"></div>
          </div>
        </div>

        <div class="pill">
          <div class="stat">
            <div class="k">Tap Dmg</div>
            <div class="v" id="dmgLabel">1</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Fire Rate</div>
            <div class="v" id="rateLabel">3.3/s</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Turret</div>
            <div class="v" id="turretLabel">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="right">
        <button class="btn small iconBtn pauseBtn" id="pauseBtn" title="Pause">‚è∏Ô∏è</button>
        <button class="btn small iconBtn" id="soundBtn" title="Toggle sound">üîä</button>
        <button class="btn small iconBtn" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div id="bossBar" class="hidden" aria-label="Boss health">
      <div class="bossLabel">BOSS</div>
      <div class="bossHp"><div class="bossHpFill" id="bossHpFill"></div></div>
      <div class="bossHpText" id="bossHpText">0/0</div>
    </div>

    <div id="settingsOverlay" class="hidden">
      <div class="backdrop" aria-hidden="true"></div>
      <div id="settingsPanel">
        <header>
          <h3>Settings</h3>
          <button class="closeSettings" id="closeSettingsBtn" aria-label="Close settings">‚úï Close</button>
        </header>
        <div class="settingRow"><label>Sound</label><div class="toggle" data-setting="sound"><div class="dot"></div></div></div>
        <div class="settingRow"><label>Vibration</label><div class="toggle" data-setting="vibration"><div class="dot"></div></div></div>
        <div class="settingRow"><label>Reduce motion</label><div class="toggle" data-setting="motion"><div class="dot"></div></div></div>
        <button class="btn bad" id="resetProgressSmall" style="width:100%; margin-top:8px">Reset Progress</button>
      </div>
    </div>

    <!-- Start / Game Over overlay -->
    <div id="mainOverlay" class="overlay">
      <div class="card">
        <header>
          <h1 class="title">üßü Zombie Tap Defense</h1>
          <p class="subtitle">
            Tap zombies to shoot. Survive waves. Buy upgrades between waves.
            <br><span class="kbd">Touch / Mouse</span> ¬∑ <span class="kbd">No build tools</span> ¬∑ <span class="kbd">GitHub Pages</span>
          </p>
        </header>
        <div class="content">
          <div class="grid">
            <div class="row">
              <div class="meta">
                <div class="name">Best Wave</div>
                <div class="desc" id="bestWaveLabel">0</div>
              </div>
              <div class="meta">
                <div class="name">Best Score</div>
                <div class="desc" id="bestScoreLabel">0</div>
              </div>
            </div>
            <div class="row">
              <div class="meta">
                <div class="name" id="overlayTitle">Tap to start</div>
                <div class="desc" id="overlayDesc">Your first tap will also unlock audio on mobile.</div>
              </div>
              <div class="footerActions">
                <button class="btn primary" id="startBtn">Start</button>
                <button class="btn" id="resetProgress">Reset Progress</button>
                <button class="btn" id="openSettingsFromStart">Settings</button>
              </div>
            </div>
            <p class="tiny">
              Assets are optional. If you add them later, put files here:
              <span class="kbd">/assets/zombie_sheet.png</span> (4 frames),
              <span class="kbd">/assets/blood.png</span>,
              <span class="kbd">/assets/hit.wav</span> <span class="kbd">kill.wav</span> <span class="kbd">hurt.wav</span> <span class="kbd">wave.wav</span>.
              The game still runs fine if they‚Äôre missing.
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Shop overlay (between waves) -->
    <div id="shopOverlay" class="overlay hidden">
      <div class="card">
        <header>
          <h2 class="title">üõí Wave cleared</h2>
          <p class="subtitle">Spend coins, then start the next wave.</p>
        </header>
        <div class="content">
          <div class="grid">
            <div class="row">
              <div class="meta">
                <div class="name">Upgrade Damage</div>
                <div class="desc" id="dmgDesc">Increase tap damage.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costDmg">‚Äî</div>
                <button class="btn primary" id="buyDmg">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Upgrade Fire Rate</div>
                <div class="desc" id="rateDesc">Shoot faster (reduces cooldown).</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costRate">‚Äî</div>
                <button class="btn primary" id="buyRate">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Turret</div>
                <div class="desc" id="turretDesc">Auto-shoots nearest zombie from bottom-center.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costTurret">‚Äî</div>
                <button class="btn good" id="buyTurret">Buy / Upgrade</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">MultiShot</div>
                <div class="desc" id="multiDesc">Hit extra targets.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costMulti">‚Äî</div>
                <button class="btn primary" id="buyMulti">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Explosive Pop</div>
                <div class="desc" id="explosiveDesc">Splash nearby 1-hp zombies.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costExplosive">‚Äî</div>
                <button class="btn primary" id="buyExplosive">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Shield</div>
                <div class="desc" id="shieldDesc">Absorb one leak.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costShield">‚Äî</div>
                <button class="btn primary" id="buyShield">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Stats</div>
                <div class="desc" id="shopStats">‚Äî</div>
              </div>
              <div class="footerActions">
                <button class="btn" id="restartBtn">Restart</button>
                <button class="btn good" id="nextWaveBtn">Start next wave</button>
              </div>
            </div>

            <p class="tiny">
              Tip: hits are forgiving (big tap radius). Runners are fast. Tanks are chunky.
              If a zombie reaches the bottom edge, you take damage and it disappears.
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Pause overlay -->
    <div id="pauseOverlay" class="overlay hidden">
      <div class="card">
        <header>
          <h2 class="title">Paused</h2>
          <p class="subtitle">Take a breather.</p>
        </header>
        <div class="content">
          <div class="footerActions">
            <button class="btn primary" id="resumeBtn">Resume</button>
            <button class="btn" id="pauseSettings">Settings</button>
            <button class="btn bad" id="pauseRestart">Restart run</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Continue overlay -->
    <div id="continueOverlay" class="overlay hidden">
      <div class="card">
        <header>
          <h2 class="title">You were overwhelmed</h2>
          <p class="subtitle" id="summarySubtitle">Choose: revive or restart.</p>
        </header>
        <div class="content">
          <div class="row">
            <div class="meta">
              <div class="name">Wave reached</div>
              <div class="desc" id="summaryWave">0</div>
            </div>
            <div class="meta">
              <div class="name">Score</div>
              <div class="desc" id="summaryScore">0</div>
            </div>
            <div class="meta">
              <div class="name">Total kills</div>
              <div class="desc" id="summaryKills">0</div>
            </div>
          </div>
          <div class="row">
            <div class="meta">
              <div class="name">Best</div>
              <div class="desc" id="summaryBest">0</div>
            </div>
            <div class="meta">
              <div class="name">Bank</div>
              <div class="desc" id="summaryBank">0</div>
            </div>
          </div>
          <div class="footerActions">
            <button class="btn primary" id="reviveBtn">Continue (revive)</button>
            <button class="btn" id="restartWave1">Restart wave 1</button>
            <button class="btn bad" id="resetFromGameOver">Reset Progress</button>
          </div>
        </div>
      </div>
    </div>

    <div id="toast">Toast</div>
  </div>

  <script>
  (() => {
    "use strict";

    /* =========================================================
       Zombie Tap Defense ‚Äî single-file canvas game
       - Canvas + vanilla JS
       - Pointer events (touch + mouse)
       - HiDPI scaling (devicePixelRatio)
       - requestAnimationFrame loop
       - Optional assets with graceful fallback
       ========================================================= */

    // ---------- DOM
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d", { alpha: true });
    const hud = document.getElementById("hud");

    const hpLabel = document.getElementById("hpLabel");
    const hpFill  = document.getElementById("hpFill");
    const hpGhost = document.getElementById("hpGhost");
    const hpPct   = document.getElementById("hpPct");
    const hpWrap  = document.querySelector(".hpWrap");
    const coinLabel = document.getElementById("coinLabel");
    const waveLabel = document.getElementById("waveLabel");
    const scoreLabel = document.getElementById("scoreLabel");
    const dmgLabel = document.getElementById("dmgLabel");
    const rateLabel = document.getElementById("rateLabel");
    const turretLabel = document.getElementById("turretLabel");
    const comboHud = document.getElementById("comboHud");
    const comboValue = document.getElementById("comboValue");
    const comboFill = document.getElementById("comboFill");
    const waveFillEl = document.getElementById("waveFill");
    const waveProgressLabel = document.getElementById("waveProgressLabel");
    const bossBar = document.getElementById("bossBar");
    const bossHpFill = document.getElementById("bossHpFill");
    const bossHpText = document.getElementById("bossHpText");

    const soundBtn = document.getElementById("soundBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsOverlay = document.getElementById("settingsOverlay");
    const settingsPanel = document.getElementById("settingsPanel");
    const closeSettingsBtn = document.getElementById("closeSettingsBtn");
    const resetProgressSmall = document.getElementById("resetProgressSmall");
    const settingsToggles = settingsPanel.querySelectorAll('.toggle');

    function updateSettingsUI(){
      settingsToggles.forEach(t => {
        const key = t.dataset.setting;
        let on = false;
        if (key === "sound") on = Save.settings.soundOn !== false;
        if (key === "vibration") on = !!Save.settings.vibrationOn;
        if (key === "motion") on = !!Save.settings.reduceMotionOn;
        t.classList.toggle('on', on);
      });
    }

    function openSettingsPanel(){
      updateSettingsUI();
      settingsOverlay.classList.remove("hidden");
      settingsOverlay.classList.add("show");
    }

    function closeSettingsPanel(){
      settingsOverlay.classList.remove("show");
      settingsOverlay.classList.add("hidden");
    }

    function toggleSettingsPanel(forceOpen=false){
      const open = forceOpen ? true : !settingsOverlay.classList.contains("show");
      if (open){
        openSettingsPanel();
      } else {
        closeSettingsPanel();
      }
    }

    const mainOverlay = document.getElementById("mainOverlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayDesc = document.getElementById("overlayDesc");
    const startBtn = document.getElementById("startBtn");
    const openSettingsFromStart = document.getElementById("openSettingsFromStart");
    const resetProgressBtn = document.getElementById("resetProgress");

    const shopOverlay = document.getElementById("shopOverlay");
    const costDmg = document.getElementById("costDmg");
    const costRate = document.getElementById("costRate");
    const costTurret = document.getElementById("costTurret");
    const costMulti = document.getElementById("costMulti");
    const costExplosive = document.getElementById("costExplosive");
    const costShield = document.getElementById("costShield");
    const buyDmg = document.getElementById("buyDmg");
    const buyRate = document.getElementById("buyRate");
    const buyTurret = document.getElementById("buyTurret");
    const buyMulti = document.getElementById("buyMulti");
    const buyExplosive = document.getElementById("buyExplosive");
    const buyShield = document.getElementById("buyShield");
    const nextWaveBtn = document.getElementById("nextWaveBtn");
    const restartBtn = document.getElementById("restartBtn");
    const shopStats = document.getElementById("shopStats");
    const dmgDesc = document.getElementById("dmgDesc");
    const rateDesc = document.getElementById("rateDesc");
    const turretDesc = document.getElementById("turretDesc");
    const multiDesc = document.getElementById("multiDesc");
    const explosiveDesc = document.getElementById("explosiveDesc");
    const shieldDesc = document.getElementById("shieldDesc");

    const pauseOverlay = document.getElementById("pauseOverlay");
    const resumeBtn = document.getElementById("resumeBtn");
    const pauseSettingsBtn = document.getElementById("pauseSettings");
    const pauseRestartBtn = document.getElementById("pauseRestart");

    const continueOverlay = document.getElementById("continueOverlay");
    const reviveBtn = document.getElementById("reviveBtn");
    const restartWave1Btn = document.getElementById("restartWave1");
    const resetFromGameOverBtn = document.getElementById("resetFromGameOver");
    const summaryWave = document.getElementById("summaryWave");
    const summaryScore = document.getElementById("summaryScore");
    const summaryKills = document.getElementById("summaryKills");
    const summaryBest = document.getElementById("summaryBest");
    const summaryBank = document.getElementById("summaryBank");
    const summarySubtitle = document.getElementById("summarySubtitle");

    const vignette = document.getElementById("vignette");

    const bestWaveLabel = document.getElementById("bestWaveLabel");
    const bestScoreLabel = document.getElementById("bestScoreLabel");
    const toastEl = document.getElementById("toast");

    // ---------- Utilities
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const rand  = (a, b) => a + Math.random() * (b - a);
    const randi = (a, b) => (a + Math.floor(Math.random() * (b - a + 1)));
    const nowMs = () => performance.now();
    const fmt = (n) => Math.floor(n).toString();
    const triWave = (t) => 2/Math.PI * Math.asin(Math.sin(t));
    const MAX_Z = 90;
    const TURRET_CHIP_BOSS = 1;
    const TURRET_CHIP_ELITE = 1;

    function showToast(msg) {
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.remove("show"), 900);
    }

    // ---------- Save System
    const SAVE_KEY = "ztd_save_v2";
    const defaultSave = () => ({
      coinsBank: 0,
      dmgLevel: 0,
      rateLevel: 0,
      turretLevel: 0,
      multishotLevel: 0,
      explosiveLevel: 0,
      shieldLevel: 0,
      bestWave: 0,
      bestScore: 0,
      totalKills: 0,
      runs: 0,
      settings: {
        soundOn: true,
        vibrationOn: false,
        reduceMotionOn: false,
      },
    });

    function loadSave(){
      let save = defaultSave();
      try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (raw) Object.assign(save, JSON.parse(raw));
      } catch (e) {}

      // remove deprecated auto shooter data safely
      if (typeof save.autoLevel !== "undefined") {
        delete save.autoLevel;
      }

      // migrate old bests
      const oldWave = +localStorage.getItem("ztd_bestWave") || 0;
      const oldScore = +localStorage.getItem("ztd_bestScore") || 0;
      save.bestWave = Math.max(save.bestWave || 0, oldWave);
      save.bestScore = Math.max(save.bestScore || 0, oldScore);
      persistSave(save);
      return save;
    }

    function persistSave(s=Save){
      localStorage.setItem(SAVE_KEY, JSON.stringify(s));
    }

    function saveGame(){
      Save.coinsBank = Player.coins;
      Save.dmgLevel = Player.dmgLevel;
      Save.rateLevel = Player.rateLevel;
      Save.turretLevel = Player.turretLevel;
      Save.multishotLevel = Player.multishotLevel;
      Save.explosiveLevel = Player.explosiveLevel;
      Save.shieldLevel = Player.shieldLevel;
      persistSave();
    }

    function resetProgress(){
      localStorage.removeItem(SAVE_KEY);
      localStorage.removeItem("ztd_bestWave");
      localStorage.removeItem("ztd_bestScore");
      Save = loadSave();
      applySaveToPlayer();
      updateHUD();
      setStartOverlay();
      showToast("Progress reset");
      continueOverlay.classList.add("hidden");
      pauseOverlay.classList.add("hidden");
    }

    let Save = loadSave();

    // ---------- Optional assets (images + sounds)
    const Assets = {
      zombieSheet: null,
      zombieSheetOk: false,
      blood: null,
      bloodOk: false,
      bloodAtlas: { cols:2, rows:2, cellW:0, cellH:0 },
    };

    function colorKeyToCanvas(img, tolerance=18){
      const c = document.createElement('canvas');
      c.width = img.width; c.height = img.height;
      const g = c.getContext('2d');
      g.drawImage(img,0,0);
      const data = g.getImageData(0,0,c.width,c.height);
      const d = data.data;
      const r0=d[0], g0=d[1], b0=d[2];
      const tol = tolerance*3;
      for (let i=0;i<d.length;i+=4){
        const dr=Math.abs(d[i]-r0)+Math.abs(d[i+1]-g0)+Math.abs(d[i+2]-b0);
        if (dr < tol) d[i+3]=0;
      }
      g.putImageData(data,0,0);
      return c;
    }

    function loadImage(url) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ ok:true, img });
        img.onerror = () => resolve({ ok:false, img:null });
        img.src = url;
      });
    }

    // Preload optional images (safe even if missing)
    Promise.all([
      loadImage("assets/zombie_sheet.png"),
      loadImage("assets/blood.png"),
    ]).then(([zs, bl]) => {
      if (zs.ok) { Assets.zombieSheet = colorKeyToCanvas(zs.img); Assets.zombieSheetOk = true; }
      if (bl.ok) {
        const c = colorKeyToCanvas(bl.img);
        Assets.blood = c; Assets.bloodOk = true;
        Assets.bloodAtlas.cellW = c.width / Assets.bloodAtlas.cols;
        Assets.bloodAtlas.cellH = c.height / Assets.bloodAtlas.rows;
      }
    });

    // ---------- Sound manager (WebAudio with unlock + optional file buffers)
    const Sound = (() => {
      let enabled = true;
      let unlocked = false;
      let ctxA = null;
      let master = null;
      const buffers = new Map();
      const sfxGains = { hit:0.30, kill:0.55, hurt:0.45, wave:0.40, ui:0.30 };

      // Optional sound files
      const soundFiles = {
        hit:  "assets/hit.wav",
        kill: "assets/kill.wav",
        hurt: "assets/hurt.wav",
        wave: "assets/wave.wav",
        ui:   "assets/ui.wav",
      };

      function setEnabled(v) {
        enabled = !!v;
        soundBtn.textContent = enabled ? "üîä Sound" : "üîá Muted";
        Save.settings.soundOn = enabled;
        persistSave();
        updateSettingsUI();
      }

      function getEnabled() { return enabled; }

      async function unlock() {
        if (unlocked) return;
        try {
          ctxA = new (window.AudioContext || window.webkitAudioContext)();
          master = ctxA.createGain();
          master.gain.value = 0.30;
          master.connect(ctxA.destination);
          await ctxA.resume();
          unlocked = true;

          // Try loading optional audio buffers (graceful if missing)
          for (const [name, url] of Object.entries(soundFiles)) {
            fetch(url).then(r => {
              if (!r.ok) throw new Error("missing");
              return r.arrayBuffer();
            }).then(ab => ctxA.decodeAudioData(ab))
              .then(buf => buffers.set(name, buf))
              .catch(() => {/* missing is fine */});
          }
        } catch (e) {
          // If WebAudio fails, just silently disable sound.
          enabled = false;
          soundBtn.textContent = "üîá Muted";
        }
      }

      function playBuffer(name, gain = 1) {
        if (!enabled || !unlocked || !ctxA || !master) return false;
        const buf = buffers.get(name);
        if (!buf) return false;
        const src = ctxA.createBufferSource();
        const g = ctxA.createGain();
        const mul = sfxGains[name] ?? 1;
        g.gain.value = clamp(gain * mul, 0, 2);
        src.buffer = buf;
        if (name === "hit" || name === "kill") src.playbackRate.value = rand(0.97, 1.03);
        src.connect(g);
        g.connect(master);
        src.start();
        return true;
      }

      // Fallback beeps (simple + mobile friendly)
      function beep({ f=440, dur=0.06, type="square", gain=0.18, slide=0 } = {}) {
        if (!enabled || !unlocked || !ctxA || !master) return;
        const o = ctxA.createOscillator();
        const g = ctxA.createGain();
        o.type = type;
        o.frequency.setValueAtTime(f, ctxA.currentTime);
        if (slide !== 0) {
          o.frequency.exponentialRampToValueAtTime(Math.max(40, f + slide), ctxA.currentTime + dur);
        }
        g.gain.setValueAtTime(0.0001, ctxA.currentTime);
        g.gain.exponentialRampToValueAtTime(gain, ctxA.currentTime + 0.008);
        g.gain.exponentialRampToValueAtTime(0.0001, ctxA.currentTime + dur);

        o.connect(g);
        g.connect(master);
        o.start();
        o.stop(ctxA.currentTime + dur + 0.01);
      }

      function play(name) {
        if (!enabled) return;
        // Try asset buffer, else fallback beep
        const ok = playBuffer(name, 1);
        if (ok) return;

        if (name === "hit")  beep({ f: 520, dur: 0.04, type:"square", gain:0.10, slide:-80 });
        if (name === "kill") beep({ f: 220, dur: 0.08, type:"sawtooth", gain:0.13, slide: 240 });
        if (name === "hurt") beep({ f: 120, dur: 0.10, type:"triangle", gain:0.17, slide:-30 });
        if (name === "wave") beep({ f: 660, dur: 0.12, type:"square", gain:0.10, slide: 200 });
        if (name === "ui")   beep({ f: 740, dur: 0.04, type:"square", gain:0.08, slide: 0 });
      }

      // Load persisted sound setting
      if (Save.settings && Save.settings.soundOn === false) enabled = false;

      setEnabled(enabled);

      return { unlock, play, setEnabled, getEnabled };
    })();

    // ---------- Game state
    const State = {
      mode: "start", // start | playing | shop | gameover | paused
      w: 0, h: 0, dpr: 1,
      playTop: 0,
      time: 0,
      lastT: nowMs(),
      shakeT: 0,
      shakeMag: 0,
      damageFlash: 0,
      hpSmooth: 100,
      hpGhost: 100,
      hitStop: 0,
      invulnUntil: 0,
      paused: false,
      reduceMotion: !!Save.settings.reduceMotionOn,
    };

    const Player = {
      maxHp: 120,
      hp: 120,
      coins: 0,
      score: 0,
      kills: 0,
      misses: 0,

      tapDamage: 1,
      tapCooldownMs: 300,

      dmgLevel: 0,
      rateLevel: 0,

      turretLevel: 0,
      turretCooldownMs: 900,
      turretLastShotAt: -1e9,
      turretHeat: 0,

      multishotLevel: 0,
      explosiveLevel: 0,

      shieldLevel: 0,
      shieldReady: false,

      lastDamageAt: nowMs(),
    };

    function recalcFromLevels(){
      Player.tapDamage = 1 + Player.dmgLevel;
      const base = 320;
      Player.tapCooldownMs = clamp(base * Math.pow(0.90, Player.rateLevel), 80, 320);
      Player.turretCooldownMs = clamp(1200 * Math.pow(0.92, Math.max(0, Player.turretLevel-1)), 460, 1200);
    }

    function applySaveToPlayer(){
      Player.coins = Save.coinsBank || 0;
      Player.dmgLevel = Save.dmgLevel || 0;
      Player.rateLevel = Save.rateLevel || 0;
      Player.turretLevel = Save.turretLevel || 0;
      Player.multishotLevel = Save.multishotLevel || 0;
      Player.explosiveLevel = Save.explosiveLevel || 0;
      Player.shieldLevel = Save.shieldLevel || 0;
      recalcFromLevels();
    }

    const COMBO_WINDOW = 2.2;
    const COMBO_MAX = 50;
    const Combo = { value:0, timer:0 };
    const REGEN_DELAY_MS = 10000;
    const REGEN_RATE = 1; // hp per second

    const Wave = {
      num: 0,
      toSpawn: 0,
      spawned: 0,
      spawnEveryMs: 650,
      nextSpawnAt: 0,
      clearedAt: 0,
      active: false,
      isBossWave: false,
      bossSpawned: false,
      mood: "NORMAL",
    };

    function updateBestLabels(){
      bestWaveLabel.textContent = String(Save.bestWave || 0);
      bestScoreLabel.textContent = String(Save.bestScore || 0);
    }
    updateBestLabels();
    applySaveToPlayer();
    State.hpSmooth = Player.hp;
    State.hpGhost = Player.hp;

    // ---------- Zombie types
    const ZOMBIE_TYPES = {
      normal: { name:"Normal", speed: 52, hp: 1,  coinMin: 2, coinMax: 3,  passDmg: 8,  r: 18 },
      runner: { name:"Runner", speed: 95, hp: 1,  coinMin: 3, coinMax: 4,  passDmg: 10, r: 16 },
      tank:   { name:"Tank",   speed: 36, hp: 3,  coinMin: 6, coinMax: 7,  passDmg: 20, r: 22 },
    };

    // ---------- Entity pools
    const zombies = []; // small count, simple objects OK

    // Blood decals (stamps) ‚Äî fixed size ring buffer
    const DECAL_MAX = 64;
    const decal = {
      x: new Float32Array(DECAL_MAX),
      y: new Float32Array(DECAL_MAX),
      rot: new Float32Array(DECAL_MAX),
      cell: new Uint8Array(DECAL_MAX),
      life: new Float32Array(DECAL_MAX),
      max: new Float32Array(DECAL_MAX),
      a: new Float32Array(DECAL_MAX),
      idx: 0,
      count: 0,
    };

    // Particles ‚Äî fixed pool (avoid allocations during play)
    const P_MAX = 650;
    const P = {
      x: new Float32Array(P_MAX),
      y: new Float32Array(P_MAX),
      vx: new Float32Array(P_MAX),
      vy: new Float32Array(P_MAX),
      life: new Float32Array(P_MAX),
      max: new Float32Array(P_MAX),
      size: new Float32Array(P_MAX),
      hue: new Float32Array(P_MAX),
      idx: 0,
    };

    // Shot tracers (tap + turret)
    const SHOT_MAX = 80;
    const Shots = {
      x1: new Float32Array(SHOT_MAX),
      y1: new Float32Array(SHOT_MAX),
      x2: new Float32Array(SHOT_MAX),
      y2: new Float32Array(SHOT_MAX),
      life: new Float32Array(SHOT_MAX),
      max: new Float32Array(SHOT_MAX),
      idx: 0,
    };

    // Floating texts
    const FT_MAX = 48;
    const FT = Array.from({length:FT_MAX}, () => ({x:0,y:0,text:"",life:0,max:0,color:"#fff",vy:-28}));
    let ftIdx = 0;

    // Impact rings
    const R_MAX = 32;
    const Rings = {x:new Float32Array(R_MAX), y:new Float32Array(R_MAX), life:new Float32Array(R_MAX), max:new Float32Array(R_MAX), r:new Float32Array(R_MAX)};
    let ringIdx=0;

    // Tap reticles
    const RET_MAX = 16;
    const Ret = {x:new Float32Array(RET_MAX), y:new Float32Array(RET_MAX), life:new Float32Array(RET_MAX), max:new Float32Array(RET_MAX)};
    let retIdx=0;

    function spawnShot(x1,y1,x2,y2,ttl=0.08){
      const i = Shots.idx;
      Shots.x1[i]=x1; Shots.y1[i]=y1; Shots.x2[i]=x2; Shots.y2[i]=y2;
      Shots.life[i]=ttl; Shots.max[i]=ttl;
      Shots.idx = (Shots.idx+1) % SHOT_MAX;
      addRing(x1,y1,8,0.14);
      addRing(x2,y2,10,0.2);
    }

    function addFloatingText(x,y,text,color="#fff",life=0.9,vy=-22){
      const ft = FT[ftIdx];
      ft.x = x; ft.y = y; ft.text = text; ft.color = color; ft.life = life; ft.max = life; ft.vy = vy;
      ftIdx = (ftIdx+1) % FT_MAX;
    }

    function addRing(x,y,r=8,life=0.2){
      const i = ringIdx;
      Rings.x[i]=x; Rings.y[i]=y; Rings.r[i]=r; Rings.life[i]=life; Rings.max[i]=life;
      ringIdx = (ringIdx+1) % R_MAX;
    }

    function addReticle(x,y){
      const i = retIdx;
      Ret.x[i]=x; Ret.y[i]=y; Ret.max[i]=0.35; Ret.life[i]=0.35;
      retIdx = (retIdx+1) % RET_MAX;
    }

    function addDecal(x,y){
      const i = decal.idx;
      decal.x[i]=x; decal.y[i]=clamp(y, State.playTop + 4, State.h - 6);
      decal.rot[i]=rand(-0.25, 0.25);
      decal.cell[i]=randi(0, 3);
      decal.max[i]=rand(3.0, 5.0);
      decal.life[i]=decal.max[i];
      decal.a[i]=rand(0.55, 0.9);
      decal.idx = (decal.idx+1) % DECAL_MAX;
      decal.count = Math.min(DECAL_MAX, decal.count+1);
    }

    function spawnParticles(x,y,count,baseSpeed=180){
      // blood-ish burst with a touch of green/gray flecks
      for (let k=0;k<count;k++){
        const i = P.idx;
        const ang = rand(0, Math.PI*2);
        const sp  = baseSpeed * rand(0.35, 1.05);
        P.x[i]=x; P.y[i]=y;
        P.vx[i]=Math.cos(ang)*sp + rand(-18,18);
        P.vy[i]=Math.sin(ang)*sp + rand(-22,22);
        const ttl = rand(0.22, 0.65);
        P.max[i]=ttl; P.life[i]=ttl;
        P.size[i]=rand(1.4, 3.8);
        P.hue[i]=Math.random() < 0.83 ? rand(350, 10) : rand(95, 140); // mostly red, some sickly green
        P.idx = (P.idx+1) % P_MAX;
      }
    }

    // ---------- Resize / HiDPI handling
    function resize() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      State.dpr = dpr;

      const hudRect = hud.getBoundingClientRect();
      State.playTop = (hudRect?.height || 0) + 8;
      bossBar.style.top = `${State.playTop + 6}px`;

      // Size canvas backing store
      const w = Math.max(320, Math.floor(rect.width));
      const h = Math.max(480, Math.floor(rect.height));
      State.w = w; State.h = h;

      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);

      // Scale drawing to CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize, { passive:true });

    // ---------- Input (pointer events, forgiving hit detection)
    const pointerState = new Map(); // pointerId -> { lastShotAt, x, y, active }

    function canvasPointFromEvent(e){
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left);
      const y = (e.clientY - r.top);
      return { x, y };
    }

    function triggerExplosion(x,y){
      if (Player.explosiveLevel <= 0) return;
      const radius = 60 + Player.explosiveLevel * 12;
      const killList = [];
      let hitSomething = false;
      for (let i=0; i<zombies.length; i++){
        const z = zombies[i];
        if (z.isCloaked) continue;
        const dx = z.x - x;
        const dy = z.y - y;
        if (dx*dx + dy*dy > radius*radius) continue;
        hitSomething = true;
        if (z.isBoss) {
          z.hp = Math.max(0, z.hp - 1);
          z.hitT = 0.08;
          if (z.hp <= 0) killList.push(i);
          continue;
        }
        if (z.maxHp <= 1 || z.hp <= 1) {
          killList.push(i);
        } else {
          z.hp = Math.max(0, z.hp - 1);
          z.hitT = 0.08;
          if (z.hp <= 0) killList.push(i);
        }
      }
      if (killList.length){
        killList.sort((a,b) => b-a);
        let lastIdx = -1;
        for (const idx of killList){
          if (idx === lastIdx) continue;
          Sound.play("kill");
          killZombieAtIndex(idx, "explosion");
          lastIdx = idx;
        }
      }
      if (hitSomething){
        spawnParticles(x,y,10,160);
        addRing(x,y,radius*0.35,0.3);
        Sound.play("hit");
      }
    }

    function applyDamageToZombie(index, dmg, { source="tap", hitSound=true, spawnFx=true, allowExplosion=true } = {}){
      const z = zombies[index];
      if (!z) return false;
      if (z.isCloaked) return false;
      if (z.invulnTimer && z.invulnTimer > 0) return false;
      z.hp -= dmg;
      z.hitT = 0.12;
      if (spawnFx) {
        const particleCount = source === "turret" ? 8 : 12;
        spawnParticles(z.x, z.y, particleCount, 140);
        addRing(z.x, z.y, 10, 0.25);
      }
      if (hitSound) Sound.play("hit");
      if (Player.explosiveLevel > 0 && allowExplosion) triggerExplosion(z.x, z.y);
      if (z.hp <= 0) {
        Sound.play("kill");
        onZombieKilled(index);
        return true;
      }
      return false;
    }

    function attemptShoot(pointerId, x, y){
        const t = nowMs();
        let ps = pointerState.get(pointerId);
        if (!ps) {
          ps = { lastShotAt: -1e9, x, y, active: true };
          pointerState.set(pointerId, ps);
        }
        if (t - ps.lastShotAt < Player.tapCooldownMs) return;

      ps.lastShotAt = t;
      ps.x = x; ps.y = y;
      addReticle(x,y);

      // Find closest zombie within forgiving radius
      let hitIdx = -1;
      let bestD2 = 1e18;
      for (let i=0;i<zombies.length;i++){
        const z = zombies[i];
        if (z.isCloaked) continue;
        // forgiving hit radius
        const rr = z.r * 1.25;
        const dx = x - z.x;
        const dy = y - (z.y - z.bob*0.25);
        const d2 = dx*dx + dy*dy;
        if (d2 <= rr*rr && d2 < bestD2){
          bestD2 = d2;
          hitIdx = i;
        }
      }

      if (hitIdx === -1) {
        Player.misses++;
        Sound.play("hit"); // subtle "pew" even on miss? feels responsive
        // small spark particles (cheaper than separate pool)
        spawnParticles(x,y,6,90);
        addRing(x,y,10,0.25);
        return;
      }

      // Hit!
      const z = zombies[hitIdx];
      spawnShot(State.w*0.5, State.h - 18, z.x, z.y);
      State.hitStop = State.reduceMotion ? 0 : 0.025;
      spawnParticles(x,y,12,140);
      applyDamageToZombie(hitIdx, Player.tapDamage, { source:"tap" });

      if (Player.multishotLevel > 0 && zombies.length > 0){
        const targeted = new Set();
        targeted.add(z);
        for (let n=0;n<Player.multishotLevel;n++){
          let best = -1;
          let bestObj = null;
          let bestD2 = 1e18;
          for (let i=0;i<zombies.length;i++){
            const cand = zombies[i];
            if (targeted.has(cand)) continue;
            if (cand.isCloaked) continue;
            const dx = cand.x - z.x;
            const dy = cand.y - z.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD2){ bestD2 = d2; best = i; bestObj = cand; }
          }
          if (best === -1) break;
          targeted.add(bestObj);
          spawnShot(State.w*0.5, State.h - 18, bestObj.x, bestObj.y, 0.1);
          applyDamageToZombie(best, Player.tapDamage, { source:"tap" });
        }
      }
    }

    function killZombieAtIndex(index, cause="generic"){
      const z = zombies[index];
      if (!z) return;
      if (z._removed) return;
      z._removed = true;

      Player.kills++;
      Save.totalKills++;
      addCoins(z.coin, z.x, z.y);
      addFloatingText(z.x, z.y-10, `+${z.coin}c`, "#facc15", 1.0, -24);

      const comboVal = addCombo(z.x, z.y - 16);
      const comboMult = Math.min(1 + comboVal * 0.06, 3);
      const baseScore = 10 + Wave.num * 3;
      const bonus = Math.floor(baseScore * comboMult) + z.coin;
      Player.score += bonus;
      if (comboVal > 0 && comboVal % 10 === 0) {
        addCoins(1, z.x, z.y - 20);
      }
      Save.bestScore = Math.max(Save.bestScore, Player.score);
      saveGame();

      // Big blood pop
      spawnParticles(z.x, z.y, randi(26, 36), 260);
      spawnParticles(z.x, z.y, 12, 90);
      addRing(z.x, z.y, 20, 0.35);
      State.hitStop = State.reduceMotion ? 0 : 0.055;
      State.shakeT = 0.18; State.shakeMag = 12;
      if (State.reduceMotion) State.shakeMag *= 0.5;
      if (navigator.vibrate && Save.settings.vibrationOn) navigator.vibrate(12);

      if (Assets.bloodOk) {
        addDecal(z.x, z.y + z.r*0.85);
      }

      // Remove zombie (swap-pop)
      const last = zombies.length - 1;
      zombies[index] = zombies[last];
      zombies.pop();
    }

    function onZombieKilled(index){
      killZombieAtIndex(index);
    }

    function applyPlayerDamage(amount, fromBottom=false){
      if (amount <= 0) return;
      if (nowMs() < State.invulnUntil) return;
      if (fromBottom && Player.shieldLevel > 0 && Player.shieldReady) {
        Player.shieldReady = false;
        addFloatingText(State.w*0.5, State.h-24, "Shield!", "#93c5fd", 0.9, -22);
        return;
      }
      Player.hp = Math.max(0, Player.hp - amount);
      Player.lastDamageAt = nowMs();
      State.shakeT = 0.18;
      State.shakeMag = 9 + amount * 0.22;
      State.damageFlash = 0.35;
      if (State.reduceMotion) { State.shakeMag *= 0.5; State.damageFlash *= 0.6; }
      vignette.style.opacity = "0.32";
      if (navigator.vibrate && Save.settings.vibrationOn) navigator.vibrate([20,30,20]);
      Sound.play("hurt");

      if (Player.hp <= 0) {
        gameOver();
      }
    }

    // Prevent page scrolling while playing (extra safe for iOS)
    function preventMove(e){
      if (State.mode === "playing") e.preventDefault();
    }
    window.addEventListener("touchmove", preventMove, { passive:false });
    window.addEventListener("wheel", (e) => { if (State.mode === "playing") e.preventDefault(); }, { passive:false });

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture?.(e.pointerId);

      const p = canvasPointFromEvent(e);

      // First interaction unlocks audio (iOS/Android requirement)
      Sound.unlock();

      if (State.mode === "start") {
        startGame();
        return;
      }
      if (State.mode !== "playing") return;

      if (!pointerState.has(e.pointerId)) {
        pointerState.set(e.pointerId, { lastShotAt: -1e9, x: p.x, y: p.y, active: true });
      } else {
        const ps = pointerState.get(e.pointerId);
        ps.x = p.x; ps.y = p.y; ps.active = true;
      }
      attemptShoot(e.pointerId, p.x, p.y);
    });

    canvas.addEventListener("pointerup", (e) => { pointerState.delete(e.pointerId); });
    canvas.addEventListener("pointercancel", (e) => { pointerState.delete(e.pointerId); });
    canvas.addEventListener("pointermove", (e) => {
      const ps = pointerState.get(e.pointerId);
      if (!ps) return;
      const p = canvasPointFromEvent(e);
      ps.x = p.x; ps.y = p.y;
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !settingsOverlay.classList.contains("hidden")) {
        closeSettingsPanel();
      }
    });

    // ---------- UI buttons
    soundBtn.addEventListener("click", () => {
      Sound.unlock(); // allow unlocking via button too
      Sound.setEnabled(!Sound.getEnabled());
      Sound.play("ui");
    });

    settingsToggles.forEach(t => {
      t.addEventListener("click", () => {
        const key = t.dataset.setting;
        if (key === "sound") Sound.setEnabled(!Sound.getEnabled());
        if (key === "vibration") { Save.settings.vibrationOn = !Save.settings.vibrationOn; persistSave(); }
        if (key === "motion") { Save.settings.reduceMotionOn = !Save.settings.reduceMotionOn; State.reduceMotion = !!Save.settings.reduceMotionOn; persistSave(); }
        updateSettingsUI();
      });
    });

    closeSettingsBtn.addEventListener("click", () => { closeSettingsPanel(); });
    settingsOverlay.addEventListener("click", (e) => {
      if (e.target === settingsOverlay || e.target.classList.contains("backdrop")) closeSettingsPanel();
    });
    settingsPanel.addEventListener("click", (e) => e.stopPropagation());

    pauseBtn.addEventListener("click", () => {
      if (State.mode !== "playing") return;
      State.paused = true;
      State.mode = "paused";
      pauseOverlay.classList.remove("hidden");
      Sound.play("ui");
    });

    resumeBtn.addEventListener("click", () => {
      if (State.mode !== "paused") return;
      State.paused = false;
      State.mode = "playing";
      pauseOverlay.classList.add("hidden");
      Sound.play("ui");
    });

    pauseRestartBtn.addEventListener("click", () => {
      Sound.play("ui");
      startGame();
    });

    pauseSettingsBtn.addEventListener("click", () => {
      toggleSettingsPanel();
    });

    settingsBtn.addEventListener("click", () => { toggleSettingsPanel(); });

    startBtn.addEventListener("click", () => {
      Sound.unlock();
      Sound.play("ui");
      startGame();
    });

    resetProgressBtn.addEventListener("click", () => { Sound.play("ui"); resetProgress(); });
    resetProgressSmall.addEventListener("click", () => { Sound.play("ui"); resetProgress(); });
    resetFromGameOverBtn.addEventListener("click", () => { Sound.play("ui"); resetProgress(); });
    openSettingsFromStart.addEventListener("click", () => { toggleSettingsPanel(true); });

    restartBtn.addEventListener("click", () => {
      Sound.play("ui");
      startGame();
    });

    nextWaveBtn.addEventListener("click", () => {
      Sound.play("wave");
      closeShopAndStartWave();
    });

    reviveBtn.addEventListener("click", () => { Sound.play("ui"); revivePlayer(); });
    restartWave1Btn.addEventListener("click", () => { Sound.play("ui"); startGame(); });

    buyDmg.addEventListener("click", () => {
      Sound.play("ui");
      const c = costDamage();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.dmgLevel++;
      Save.dmgLevel = Player.dmgLevel;
      recalcFromLevels();
      persistSave();
      showToast("Damage upgraded");
      updateShopUI();
    });

    buyRate.addEventListener("click", () => {
      Sound.play("ui");
      const c = costRateUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.rateLevel++;
      Save.rateLevel = Player.rateLevel;
      recalcFromLevels();
      persistSave();
      showToast("Fire rate upgraded");
      updateShopUI();
    });

    buyTurret.addEventListener("click", () => {
      Sound.play("ui");
      const c = costTurretUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.turretLevel++;
      Save.turretLevel = Player.turretLevel;
      recalcFromLevels();
      saveGame();
      showToast(Player.turretLevel === 1 ? "Turret installed" : "Turret upgraded");
      updateShopUI();
    });

    buyMulti.addEventListener("click", () => {
      Sound.play("ui");
      const c = costMultiUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.multishotLevel = Math.min(2, Player.multishotLevel + 1);
      Save.multishotLevel = Player.multishotLevel;
      saveGame();
      showToast("MultiShot upgraded");
      updateShopUI();
    });

    buyExplosive.addEventListener("click", () => {
      Sound.play("ui");
      const c = costExplosiveUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.explosiveLevel = Math.min(2, Player.explosiveLevel + 1);
      Save.explosiveLevel = Player.explosiveLevel;
      saveGame();
      showToast("Explosive Pop upgraded");
      updateShopUI();
    });

    buyShield.addEventListener("click", () => {
      Sound.play("ui");
      const c = costShieldUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.shieldLevel = 1;
      Player.shieldReady = true;
      Save.shieldLevel = 1;
      saveGame();
      showToast("Shield ready");
      updateShopUI();
    });

    // ---------- Costs (scale each purchase)
    function costDamage(){
      return Math.floor(30 * Math.pow(1.45, Player.dmgLevel));
    }
    function costRateUp(){
      return Math.floor(35 * Math.pow(1.55, Player.rateLevel));
    }
    function costTurretUp(){
      // first purchase is pricier, then scales
      const lvl = Player.turretLevel;
      const base = (lvl === 0) ? 80 : 65;
      return Math.floor(base * Math.pow(1.60, lvl));
    }
    function costMultiUp(){
      return Player.multishotLevel >= 2 ? Infinity : Math.floor(90 * Math.pow(1.85, Player.multishotLevel));
    }
    function costExplosiveUp(){
      return Player.explosiveLevel >= 2 ? Infinity : Math.floor(110 * Math.pow(1.85, Player.explosiveLevel));
    }
    function costShieldUp(){
      return Player.shieldLevel >= 1 ? Infinity : 200;
    }

    function spendCoins(cost){
      if (Player.coins < cost) return false;
      Player.coins -= cost;
      saveGame();
      return true;
    }

    function addCoins(amount,x=State.w*0.5,y=State.h*0.5){
      if (!amount) return;
      Player.coins += amount;
      coinLabel.classList.remove("pop");
      void coinLabel.offsetWidth;
      coinLabel.classList.add("pop");
      saveGame();
      addFloatingText(x,y,`+${amount}ü™ô`,`#facc15`,0.9,-26);
    }

    function updateComboUI(){
      const active = Combo.value > 0 && Combo.timer > 0;
      const pct = active ? clamp(Combo.timer / COMBO_WINDOW, 0, 1) : 0;
      comboHud.style.opacity = active ? 1 : 0.45;
      comboValue.textContent = active ? `x${Combo.value}` : "‚Äî";
      comboFill.style.width = `${pct * 100}%`;
    }

    function addCombo(x=State.w-40, y=60){
      if (Combo.timer > 0 && Combo.value > 0) Combo.value++;
      else Combo.value = 1;
      Combo.value = Math.min(COMBO_MAX, Combo.value);
      Combo.timer = COMBO_WINDOW;
      comboHud.classList.remove("pop");
      void comboHud.offsetWidth;
      comboHud.classList.add("pop");
      addFloatingText(x, y, `COMBO x${Combo.value}`, "#a855f7", 0.8, -12);
      updateComboUI();
      return Combo.value;
    }

    function resetCombo(showToastMessage=false){
      if (showToastMessage && Combo.value > 0) showToast("Combo lost");
      Combo.value = 0; Combo.timer = 0;
      updateComboUI();
    }

    function pickWaveMood(waveNum){
      const roll = Math.random();
      if (roll < 0.20) return "SWARM";
      if (roll < 0.35) return "RUNNERS";
      if (roll < 0.50) return "MUTATION";
      return "NORMAL";
    }

    // ---------- Game flow
    function resetAll(){
      zombies.length = 0;
      pointerState.clear();
      Player.hp = Player.maxHp;
      Player.score = 0;
      Player.kills = 0;
      Player.misses = 0;
      Player.turretLastShotAt = -1e9;
      Player.turretHeat = 0;
      Player.coins = Save.coinsBank;
      Player.shieldReady = Player.shieldLevel > 0;
      Player.lastDamageAt = nowMs();
      recalcFromLevels();
      Combo.value = 0; Combo.timer = 0;
      State.invulnUntil = 0;
      State.hpSmooth = Player.hp;
      State.hpGhost = Player.hp;
      vignette.style.opacity = "0";
      bossBar.classList.add("hidden");

      Wave.num = 0;
      Wave.active = false;
      Wave.toSpawn = 0;
      Wave.spawned = 0;
      Wave.spawnEveryMs = 650;
      Wave.nextSpawnAt = 0;
      Wave.clearedAt = 0;
      Wave.isBossWave = false;
      Wave.bossSpawned = false;

      State.shakeT = 0;
      State.shakeMag = 0;
      State.damageFlash = 0;

      // clear decals quickly
      decal.count = 0;

      // clear particle lifetimes (cheap)
      for (let i=0;i<P_MAX;i++) P.life[i] = 0;
      for (let i=0;i<SHOT_MAX;i++) Shots.life[i] = 0;
    }

    function startGame(){
      resetAll();
      Save.runs = (Save.runs||0)+1;
      persistSave();
      State.mode = "playing";
      State.paused = false;
      mainOverlay.classList.add("hidden");
      shopOverlay.classList.add("hidden");
      continueOverlay.classList.add("hidden");
      pauseOverlay.classList.add("hidden");
      closeSettingsPanel();
      startNextWave();
      updateHUD();
    }

    function revivePrice(){
      return Math.max(60, 120 + Wave.num * 25);
    }

    function revivePlayer(){
      const cost = revivePrice();
      if (!spendCoins(cost)) return showToast("Not enough coins");
      Player.hp = Math.ceil(Player.maxHp * 0.5);
      Player.lastDamageAt = nowMs();
      State.invulnUntil = nowMs() + 1200;
      zombies.length = 0;
      Wave.spawned = 0;
      Wave.active = true;
      Wave.isBossWave = (Wave.num % 5 === 0);
      Wave.bossSpawned = false;
      Wave.mood = pickWaveMood(Wave.num);
      const w = Wave.num;
      let toSpawn = Wave.isBossWave ? 1 : Math.floor(18 + w * 6.0 + Math.pow(w, 1.12) * 1.4);
      if (Wave.mood === "SWARM") toSpawn = Math.floor(toSpawn * 1.45);
      if (Wave.mood === "RUNNERS") toSpawn = Math.floor(toSpawn * 1.15);
      if (Wave.mood === "MUTATION") toSpawn = Math.floor(toSpawn * 1.10);
      Wave.toSpawn = toSpawn;
      Wave.spawnEveryMs = Wave.isBossWave ? 900 : clamp(620 - w * 30, 140, 620);
      Wave.nextSpawnAt = nowMs() + 450;
      if (Player.shieldLevel > 0) Player.shieldReady = true;
      saveGame();
      continueOverlay.classList.add("hidden");
      State.mode = "playing";
      updateHUD();
    }

    function gameOver(){
      State.mode = "gameover";
      Wave.active = false;
      Save.bestWave = Math.max(Save.bestWave || 0, Wave.num);
      Save.bestScore = Math.max(Save.bestScore || 0, Player.score);
      saveGame();
      updateBestLabels();

      summaryWave.textContent = Wave.num;
      summaryScore.textContent = Player.score;
      summaryKills.textContent = Player.kills;
      summaryBest.textContent = `Wave ${Save.bestWave} ¬∑ Score ${Save.bestScore}`;
      summaryBank.textContent = Player.coins;
      const reviveCost = revivePrice();
      summarySubtitle.textContent = `Continue for ${reviveCost} coins or restart from wave 1 (upgrades + bank are kept).`;
      reviveBtn.textContent = `Continue (-${reviveCost} coins)`;
      continueOverlay.classList.remove("hidden");
      mainOverlay.classList.add("hidden");
    }

    function startNextWave(){
      if (Player.shieldLevel > 0) Player.shieldReady = true;
      Wave.num++;
      Wave.active = true;
      Wave.isBossWave = (Wave.num % 5 === 0);
      Wave.bossSpawned = false;
      Wave.mood = pickWaveMood(Wave.num);

      const w = Wave.num;
      let toSpawn = Wave.isBossWave ? 1 : Math.floor(18 + w * 6.0 + Math.pow(w, 1.12) * 1.4);
      if (Wave.mood === "SWARM") toSpawn = Math.floor(toSpawn * 1.45);
      if (Wave.mood === "RUNNERS") toSpawn = Math.floor(toSpawn * 1.15);
      if (Wave.mood === "MUTATION") toSpawn = Math.floor(toSpawn * 1.10);
      Wave.toSpawn = toSpawn;
      Wave.spawned = 0;

      // Faster spawn at higher waves
      Wave.spawnEveryMs = Wave.isBossWave ? 900 : clamp(620 - w * 30, 140, 620);
      Wave.nextSpawnAt = nowMs() + 250;

      // Reward a tiny ‚Äúbreather‚Äù after shop
      Sound.play("wave");
      updateHUD();
    }

    function waveCleared(){
      Wave.active = false;
      Wave.clearedAt = nowMs();
      State.mode = "shop";
      const waveBonus = Math.floor(6 + Wave.num * 1.2);
      addCoins(waveBonus, State.w*0.5, State.playTop + 20);
      if (Wave.num > (Save.bestWave||0)) { Save.bestWave = Wave.num; persistSave(); updateBestLabels(); }
      saveGame();
      openShop();
    }

    function openShop(){
      updateShopUI();
      shopOverlay.classList.remove("hidden");
    }

    function closeShopAndStartWave(){
      shopOverlay.classList.add("hidden");
      State.mode = "playing";
      startNextWave();
    }

    function updateShopUI(){
      costDmg.textContent = `Cost: ${costDamage()} coins`;
      costRate.textContent = `Cost: ${costRateUp()} coins`;
      costTurret.textContent = Player.turretLevel === 0 ? `Cost: ${costTurretUp()} (install)` : `Cost: ${costTurretUp()} coins`;
      costMulti.textContent = Player.multishotLevel >= 2 ? `Maxed` : `Cost: ${costMultiUp()} coins`;
      costExplosive.textContent = Player.explosiveLevel >= 2 ? `Maxed` : `Cost: ${costExplosiveUp()} coins`;
      costShield.textContent = Player.shieldLevel >= 1 ? `Owned` : `Cost: ${costShieldUp()} coins`;

      buyDmg.disabled = Player.coins < costDamage();
      buyRate.disabled = Player.coins < costRateUp();
      buyTurret.disabled = Player.coins < costTurretUp();
      buyMulti.disabled = Player.coins < costMultiUp();
      buyExplosive.disabled = Player.coins < costExplosiveUp();
      buyShield.disabled = Player.coins < costShieldUp();

      buyDmg.style.opacity = buyDmg.disabled ? 0.55 : 1;
      buyRate.style.opacity = buyRate.disabled ? 0.55 : 1;
      buyTurret.style.opacity = buyTurret.disabled ? 0.55 : 1;
      buyMulti.style.opacity = buyMulti.disabled ? 0.55 : 1;
      buyExplosive.style.opacity = buyExplosive.disabled ? 0.55 : 1;
      buyShield.style.opacity = buyShield.disabled ? 0.55 : 1;

      dmgDesc.textContent = `+1 tap dmg (Lv ${Player.dmgLevel})`;
      rateDesc.textContent = `Shoot ${(1000/Player.tapCooldownMs).toFixed(1)}/s ‚Üí ${(1000/Math.max(80, Player.tapCooldownMs*0.9)).toFixed(1)}/s`;
      const nextTurretCd = clamp(Player.turretCooldownMs * 0.92, 240, 900);
      turretDesc.textContent = Player.turretLevel === 0 ? "Install an auto turret" : `Fire ${(1000/Player.turretCooldownMs).toFixed(1)}/s ‚Üí ${(1000/nextTurretCd).toFixed(1)}/s`;
      const msNext = Player.multishotLevel === 0 ? "+1 target" : Player.multishotLevel === 1 ? "+2 targets" : "maxed";
      multiDesc.textContent = `Hit ${Player.multishotLevel === 0 ? "1" : Player.multishotLevel + 1} target(s) ‚Üí ${msNext}`;
      const explRadius = 60 + Player.explosiveLevel * 12;
      explosiveDesc.textContent = Player.explosiveLevel >= 2 ? `Explodes nearby 1-hp foes (radius ${explRadius}) (maxed)` : `Splash pops 1-hp in r${explRadius}`;
      shieldDesc.textContent = Player.shieldLevel ? "Shield charged (blocks one leak)" : "Absorb one leak";

      const ratePerSec = (1000 / Player.tapCooldownMs).toFixed(1);
      const turretTxt = Player.turretLevel === 0 ? "none" : `Lv ${Player.turretLevel}`;
      const multiTxt = Player.multishotLevel === 0 ? "‚Äî" : `Lv ${Player.multishotLevel}`;
      const explTxt = Player.explosiveLevel === 0 ? "‚Äî" : `Lv ${Player.explosiveLevel}`;
      const shieldTxt = Player.shieldLevel === 0 ? "‚Äî" : (Player.shieldReady ? "Ready" : "Used");
      shopStats.textContent =
        `Bank ${Player.coins} ¬∑ Tap dmg ${Player.tapDamage} ¬∑ Fire ${ratePerSec}/s ¬∑ Turret ${turretTxt} ¬∑ Multi ${multiTxt} ¬∑ Explo ${explTxt} ¬∑ Shield ${shieldTxt}`;
      updateHUD();
    }

    // ---------- Spawning zombies (wave-based difficulty + types)
    function chooseZombieType(waveNum){
      const baseRunner = clamp(0.22 + waveNum * 0.012, 0.22, 0.62);
      let runnerW = baseRunner;
      let normalW = 1 - baseRunner;
      // nudge by mood
      if (Wave.mood === "RUNNERS") runnerW += 0.30;
      if (Wave.mood === "SWARM") normalW += 0.22;
      const total = runnerW + normalW;
      const r = Math.random() * total;
      return (r < runnerW) ? "runner" : "normal";
    }

    function spawnZombie(){
      let typeKey = chooseZombieType(Wave.num);
      const margin = 26;
      const x = rand(margin, State.w - margin);
      const y = rand(State.playTop + 10, State.playTop + 50);

      // Elite / tank rolls
      const eliteChance = clamp(0.04 + Wave.num * 0.003, 0.04, 0.14);
      const tankChance = Wave.num >= 12 ? clamp(0.01 + Wave.num * 0.0012, 0.01, 0.04) : 0;
      let hpType = "normal";
      let rank = "normal";
      if (!Wave.isBossWave && Math.random() < tankChance) {
        typeKey = "tank";
        hpType = "tank";
        rank = "elite";
      } else if (!Wave.isBossWave && Math.random() < eliteChance) {
        hpType = "elite";
        rank = "elite";
      }

      const base = ZOMBIE_TYPES[typeKey];

      const speedScale = 1 + Wave.num * 0.060;  // slightly faster each wave
      const speedJitter = rand(0.9, 1.08);

      let maxHp = base.hp;
      if (hpType === "elite") maxHp = Math.max(2, Math.ceil(base.hp * 1.1));
      if (hpType === "tank") maxHp = Math.max(3, Math.ceil(base.hp * 1.0));

      // Sprinters (runners that go extra fast)
      let sprinter = false;
      let sprintMult = 1;
      if (typeKey === "runner" && Wave.num > 6) {
        const sprinterChance = clamp(0.10 + Wave.num * 0.012, 0.10, 0.22);
        if (Math.random() < sprinterChance) {
          sprinter = true;
          const high = clamp(1.5 + Wave.num * 0.015, 1.5, 2.0);
          sprintMult = rand(1.35, high);
        }
      }

      let vy = base.speed * speedScale * speedJitter * sprintMult;
      if (maxHp === 2) vy *= 0.92;
      if (maxHp >= 3) vy *= 0.78;

      // Horizontal drift
      const wiggleChance = clamp(0.22 + Wave.num * 0.010, 0.22, 0.48);
      const shouldWiggle = Math.random() < wiggleChance;
      let wiggleAmp = shouldWiggle ? rand(15, 80) * (1 + Wave.num * 0.02) : 0;
      wiggleAmp = clamp(wiggleAmp * (sprinter ? 0.6 : 1), 15, 120);
      const wiggleFreq = shouldWiggle ? rand(1.0, 3.2) : 0;
      const wigglePhase = rand(0, Math.PI*2);
      const wiggleMode = shouldWiggle && Math.random() < (Wave.num > 8 ? 0.45 : 0.28) ? "tri" : "sin";

      const baseCoin = randi(base.coinMin, base.coinMax);
      const coinInflate = Math.floor(Wave.num * 0.08);
      let coin = baseCoin + coinInflate;
      if (rank === "elite") coin += (maxHp >= 3 ? 4 : 2);
      if (sprinter) coin += 1;

      const z = {
        type: typeKey,
        x, y,
        x0: x,
        vy,
        speedJitter,
        sprinter,
        wiggleAmp,
        wiggleFreq,
        wigglePhase,
        wiggleMode,
        r: base.r * (sprinter ? 0.92 : maxHp >= 3 ? 1.18 : maxHp === 2 ? 1.05 : 1),
        maxHp,
        hp: 0,
        coin,
        passDmg: base.passDmg + Math.floor(Wave.num * 0.12) + (maxHp > 1 ? 5 : 0),
        elite: rank === "elite",
        isBoss: false,
        rank,
        hpType,

        // animation
        t: rand(0, 10),
        bob: 0,
        step: rand(0, Math.PI*2),
        hitT: 0,

        mutation: "none",
        isCloaked: false,
        cloakTimer: 0,
        nextCloak: 0,
        dashTime: 0,
        nextDash: 0,
        dashMult: 1,
        invulnTimer: 0,
        blinkFlash: 0,

        // sprite frame timer
        frame: 0,
        frameT: 0,
      };
      // mutation roll (non-boss)
      if (!Wave.isBossWave) {
        let mutChance = clamp(0.02 + Wave.num * 0.0025, 0.02, 0.10);
        if (Wave.mood === "MUTATION") mutChance = Math.min(0.18, 0.10 + mutChance);
        if (Math.random() < mutChance) {
          const roll = Math.random();
          if (roll < 0.34) z.mutation = "blink"; else if (roll < 0.67) z.mutation = "cloak"; else z.mutation = "dash";
          if (z.mutation === "blink") {
            z.nextBlink = rand(1.2, 2.0);
            z.blinkFlash = 0.35;
          }
          if (z.mutation === "cloak") {
            z.nextCloak = rand(1.8, 2.6);
            z.cloakTimer = 0;
          }
          if (z.mutation === "dash") {
            z.nextDash = rand(1.6, 2.4);
            z.dashTime = 0;
          }
        }
      }

      z.hp = z.maxHp;
      zombies.push(z);
    }

    function spawnBoss(){
      const bossMaxHp = Math.floor(35 + Wave.num * 12);
      const baseSpeed = 30 + Wave.num * 0.5;
      const margin = 32;
      const x = rand(margin, State.w - margin);
      const y = rand(State.playTop + 12, State.playTop + 38);
      const z = {
        type: "boss",
        rank: "boss",
        isBoss: true,
        elite: true,
        x, y,
        x0: x,
        vy: baseSpeed,
        r: 30,
        maxHp: bossMaxHp,
        hp: bossMaxHp,
        coin: 30 + Math.floor(Wave.num * 5),
        passDmg: 30 + Math.floor(Wave.num * 1.2),
        t: rand(0, 10),
        bob: 0,
        step: rand(0, Math.PI*2),
        hitT: 0,
        wiggleAmp: 10,
        wiggleFreq: 0.35,
        wigglePhase: rand(0, Math.PI*2),
        frame: 0,
        frameT: 0,
        mutation: "none",
        isCloaked: false,
      };
      zombies.push(z);
    }

    // ---------- Turret logic
    function turretDamage(){
      if (Player.turretLevel <= 0) return 0;
      // Turret damage scales gently (slightly toned down)
      return 1 + Math.floor(Player.turretLevel * 0.80);
    }

    function turretTryShoot(){
      if (Player.turretLevel <= 0) return;
      const t = nowMs();
      const heatMult = 1 + Player.turretHeat * 1.8;
      const cd = Player.turretCooldownMs * heatMult;
      if (t - Player.turretLastShotAt < cd) return;
      if (zombies.length === 0) return;

      // Nearest zombie (simple O(n) is fine for ~60)
      const tx = State.w * 0.5;
      const ty = State.h - 18;

      let best = -1;
      let bestY = -1;
      let bestD2 = 1e18;
      for (let i=0;i<zombies.length;i++){
        const z = zombies[i];
        if (z.isCloaked) continue;
        const dx = z.x - tx;
        const dy = z.y - ty;
        const d2 = dx*dx + dy*dy;
        if (z.y > bestY || (Math.abs(z.y - bestY) < 6 && d2 < bestD2)) { bestY = z.y; bestD2 = d2; best = i; }
      }
      if (best === -1) return;

      Player.turretLastShotAt = t;
      Player.turretHeat = Math.min(1, Player.turretHeat + 0.06);

      const z = zombies[best];
      let dmg = turretDamage();
      if (z.isBoss) dmg = TURRET_CHIP_BOSS; else if (z.elite) dmg = Math.min(dmg, TURRET_CHIP_ELITE);

      spawnShot(tx, ty, z.x, z.y, 0.09);
      applyDamageToZombie(best, dmg, { source:"turret" });
    }

    // ---------- HUD updates
    function updateHUD(){
      hpLabel.textContent = fmt(Player.hp);
      const pct = clamp(Player.hp / Player.maxHp, 0, 1);
      const pctSmooth = clamp(State.hpSmooth / Player.maxHp, 0, 1);
      const pctGhost = clamp(State.hpGhost / Player.maxHp, 0, 1);
      hpFill.style.transform = `scaleX(${pctSmooth})`;
      hpGhost.style.transform = `scaleX(${pctGhost})`;
      const shieldTag = Player.shieldLevel && Player.shieldReady ? " ¬∑ Shield" : "";
      hpPct.textContent = `${fmt(pct*100)}%${shieldTag}`;
      hpFill.style.background = pct < 0.25 ? "linear-gradient(90deg, rgba(239,68,68,.95), rgba(248,113,113,.65))" : pct < 0.5 ? "linear-gradient(90deg, rgba(245,158,11,.95), rgba(251,191,36,.65))" : "linear-gradient(90deg, rgba(34,197,94,.95), rgba(34,197,94,.55))";
      vignette.style.opacity = pct < 0.35 ? lerp(0.2, 0.55, 1-pct) : "0";

      coinLabel.textContent = fmt(Player.coins);
      waveLabel.textContent = fmt(Wave.num);
      scoreLabel.textContent = fmt(Player.score);
      const soundOn = Sound.getEnabled();
      soundBtn.classList.toggle("toggleOn", soundOn);
      soundBtn.textContent = soundOn ? "üîä" : "üîá";

      dmgLabel.textContent = `${fmt(Player.tapDamage)} (Lv ${Player.dmgLevel})`;
      rateLabel.textContent = `${(1000/Player.tapCooldownMs).toFixed(1)}/s (Lv ${Player.rateLevel})`;
      turretLabel.textContent = Player.turretLevel ? `Lv ${Player.turretLevel}` : "‚Äî";

      const totalWave = Math.max(Wave.toSpawn, 1);
      const remaining = zombies.length + Math.max(0, Wave.toSpawn - Wave.spawned);
      const progress = clamp(1 - (remaining / totalWave), 0, 1);
      waveFillEl.style.width = `${progress*100}%`;
      waveProgressLabel.textContent = `${Math.max(0, totalWave-remaining)}/${totalWave}`;

      updateBossUI();
    }

    function findBoss(){
      for (let i=0;i<zombies.length;i++){
        if (zombies[i].isBoss) return zombies[i];
      }
      return null;
    }

    function updateBossUI(){
      const boss = findBoss();
      const show = !!boss && (State.mode === "playing" || State.mode === "paused");
      bossBar.classList.toggle("hidden", !show);
      if (!show) return;
      bossBar.style.top = `${State.playTop + 6}px`;
      const pct = clamp(boss.hp / boss.maxHp, 0, 1);
      bossHpFill.style.transform = `scaleX(${pct})`;
      bossHpText.textContent = `${Math.max(0, Math.ceil(boss.hp))}/${Math.max(1, Math.floor(boss.maxHp))}`;
    }

    // ---------- Rendering helpers
    function drawRoundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function drawZombieProcedural(z){
      // A simple animated ‚Äúwalking‚Äù zombie: head + body + swinging legs + bob
      const x = z.x;
      const y = z.y - z.bob;
      const s = 1 + (z.hitT > 0 ? 0.06 : 0); // tiny hit pop
      const r = z.r * s;

      // Colors by type (subtle)
      const isRunner = z.type === "runner";
      const isTank   = z.type === "tank";
      const isSprinter = !!z.sprinter;
      const skin = isTank ? "rgba(140, 190, 120, 0.95)" : isRunner ? (isSprinter ? "rgba(135, 185, 240, 0.95)" : "rgba(125, 200, 145, 0.95)") : "rgba(120, 190, 135, 0.95)";
      const cloth= isTank ? "rgba(60, 80, 92, 0.95)" : isRunner ? (isSprinter ? "rgba(90, 110, 170, 0.95)" : "rgba(70, 86, 105, 0.95)") : "rgba(68, 84, 100, 0.95)";
      const dark = "rgba(10,12,16,.65)";
      const outline = z.hitT > 0 ? "rgba(255,255,255,.28)" : "rgba(0,0,0,.35)";

      ctx.save();
      ctx.translate(x, y);

      // mutation glows / trails
      if (z.mutation === "dash" && z.dashTime > 0) {
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = "rgba(248,113,113,0.65)";
        ctx.beginPath();
        ctx.moveTo(-r*0.8, r*0.35);
        ctx.lineTo(-r*1.6, r*0.05);
        ctx.lineTo(-r*0.8, -r*0.25);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      if (z.mutation === "blink") {
        const glowA = 0.22 + (z.blinkFlash || 0) * 0.9;
        ctx.globalAlpha = clamp(glowA, 0, 0.55);
        ctx.fillStyle = "rgba(168,85,247,0.9)";
        ctx.beginPath();
        ctx.arc(0, 0, r*1.35, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      const baseAlpha = z.isCloaked ? 0.18 : 1;

      // shadow
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.beginPath();
      ctx.ellipse(0, r*1.25, r*0.9, r*0.35, 0, 0, Math.PI*2);
      ctx.fill();

      if (isSprinter) {
        ctx.globalAlpha = 0.30;
        ctx.fillStyle = "rgba(96,165,250,.9)";
        ctx.beginPath();
        ctx.ellipse(-r*0.2, r*0.55, r*0.9, r*0.35, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      if (z.elite) {
        ctx.strokeStyle = z.maxHp >= 3 ? "rgba(248,113,113,.9)" : "rgba(250,204,21,.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, r*1.15, 0, Math.PI*2);
        ctx.stroke();
        ctx.fillStyle = z.maxHp >= 3 ? "rgba(248,113,113,.8)" : "rgba(250,204,21,.8)";
        ctx.beginPath();
        ctx.arc(r*0.62, -r*0.9, r*0.22, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.globalAlpha = baseAlpha;

      // legs swing
      const swing = Math.sin(z.step) * (isTank ? 0.22 : isRunner ? 0.55 : 0.38);
      const legY = r*1.10;
      const legLen = r*0.9;

      ctx.lineCap = "round";
      ctx.lineWidth = Math.max(2, r*0.16);
      ctx.strokeStyle = "rgba(30,35,45,.95)";

      ctx.beginPath();
      ctx.moveTo(-r*0.25, legY);
      ctx.lineTo(-r*0.25 + swing*r*0.32, legY + legLen);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r*0.25, legY);
      ctx.lineTo(r*0.25 - swing*r*0.32, legY + legLen);
      ctx.stroke();

      // body
      ctx.fillStyle = cloth;
      ctx.strokeStyle = outline;
      ctx.lineWidth = Math.max(1.5, r*0.08);
      drawRoundedRect(-r*0.62, -r*0.10, r*1.24, r*1.25, r*0.35);
      ctx.fill();
      ctx.stroke();

      // arms
      ctx.strokeStyle = "rgba(35,45,55,.9)";
      ctx.lineWidth = Math.max(2, r*0.12);
      ctx.beginPath();
      ctx.moveTo(-r*0.62, r*0.35);
      ctx.lineTo(-r*0.98, r*0.55 + swing*r*0.15);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(r*0.62, r*0.35);
      ctx.lineTo(r*0.98, r*0.55 - swing*r*0.15);
      ctx.stroke();

      // head
      ctx.fillStyle = skin;
      ctx.strokeStyle = outline;
      ctx.lineWidth = Math.max(1.2, r*0.08);
      ctx.beginPath();
      ctx.arc(0, -r*0.70, r*0.55, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // eyes + mouth
      ctx.fillStyle = z.mutation === "dash" ? "rgba(248,113,113,.75)" : "rgba(0,0,0,.55)";
      ctx.beginPath();
      ctx.arc(-r*0.18, -r*0.78, r*0.08, 0, Math.PI*2);
      ctx.arc(r*0.18, -r*0.78, r*0.08, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = dark;
      ctx.lineWidth = Math.max(1, r*0.06);
      ctx.beginPath();
      ctx.arc(0, -r*0.58, r*0.18, 0.1*Math.PI, 0.9*Math.PI);
      ctx.stroke();

      if (z.isCloaked) {
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = "rgba(125,211,252,0.8)";
        ctx.lineWidth = Math.max(1, r*0.05);
        ctx.beginPath();
        ctx.arc(0, 0, r*1.1, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = baseAlpha;
      }

      // HP bar (only if damaged and multi-hit)
      if (z.maxHp > 1 && z.hp < z.maxHp) {
        const bw = r*1.3;
        const bh = Math.max(4, r*0.18);
        const px = -bw/2;
        const py = -r*1.42;
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(px, py, bw, bh);
        const t = clamp(z.hp / z.maxHp, 0, 1);
        ctx.fillStyle = t > 0.5 ? "rgba(34,197,94,.9)" : t > 0.25 ? "rgba(245,158,11,.9)" : "rgba(239,68,68,.9)";
        ctx.fillRect(px, py, bw * t, bh);
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.strokeRect(px, py, bw, bh);
      }

      ctx.restore();
    }

    function drawZombieSprite(z){
      const img = Assets.zombieSheet;
      if (!img) return false;

      // Assume 4 frames horizontally, single row
      const frames = 4;
      const fw = img.width / frames;
      const fh = img.height;

      const x = z.x;
      const y = z.y - z.bob;

      // animate
      z.frameT += 1/60; // approximate, will also update in update()
      const f = z.frame % frames;

      const scale = (z.type === "tank") ? 1.25 : (z.type === "runner") ? 0.95 : 1.05;
      const size = z.r * 2.2 * scale;

      ctx.save();
      ctx.translate(x, y);
      const hitS = (z.hitT > 0) ? 1.08 : 1.0;
      ctx.scale(hitS, hitS);

      if (z.mutation === "dash" && z.dashTime > 0) {
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = "rgba(248,113,113,0.65)";
        ctx.beginPath();
        ctx.moveTo(-z.r*0.8, z.r*0.35);
        ctx.lineTo(-z.r*1.6, z.r*0.05);
        ctx.lineTo(-z.r*0.8, -z.r*0.25);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      if (z.mutation === "blink") {
        const glowA = 0.22 + (z.blinkFlash || 0) * 0.9;
        ctx.globalAlpha = clamp(glowA, 0, 0.55);
        ctx.fillStyle = "rgba(168,85,247,0.9)";
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.35, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      const baseAlpha = z.isCloaked ? 0.18 : 1;

      // shadow
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.beginPath();
      ctx.ellipse(0, z.r*1.3, z.r*0.95, z.r*0.38, 0, 0, Math.PI*2);
      ctx.fill();

      if (z.elite) {
        ctx.strokeStyle = "rgba(250,204,21,.85)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.2, 0, Math.PI*2);
        ctx.stroke();
      }

      // image
      ctx.globalAlpha = 0.98 * baseAlpha;
      ctx.drawImage(img, f*fw, 0, fw, fh, -size/2, -size/2, size, size);

      if (z.sprinter) {
        ctx.globalAlpha = 0.26;
        ctx.fillStyle = "rgba(96,165,250,.9)";
        ctx.beginPath();
        ctx.ellipse(-z.r*0.2, z.r*0.6, z.r*0.95, z.r*0.35, 0, 0, Math.PI*2);
        ctx.fill();
      }

      if (z.elite) {
        ctx.globalAlpha = 0.8;
        ctx.strokeStyle = z.maxHp >= 3 ? "rgba(248,113,113,.9)" : "rgba(250,204,21,.85)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.2, 0, Math.PI*2);
        ctx.stroke();
      }

      if (z.isCloaked) {
        ctx.globalAlpha = 0.45;
        ctx.strokeStyle = "rgba(125,211,252,0.8)";
        ctx.lineWidth = Math.max(1, z.r*0.05);
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.1, 0, Math.PI*2);
        ctx.stroke();
      }

      // outline on hit
      if (z.hitT > 0) {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(255,255,255,.28)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.05, 0, Math.PI*2);
        ctx.stroke();
      }

      // HP bar
      if (z.maxHp > 1 && z.hp < z.maxHp) {
        const bw = z.r*1.35;
        const bh = Math.max(4, z.r*0.18);
        const px = -bw/2;
        const py = -z.r*1.45;
        ctx.globalAlpha = 1;
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(px, py, bw, bh);
        const t = clamp(z.hp / z.maxHp, 0, 1);
        ctx.fillStyle = t > 0.5 ? "rgba(34,197,94,.9)" : t > 0.25 ? "rgba(245,158,11,.9)" : "rgba(239,68,68,.9)";
        ctx.fillRect(px, py, bw*t, bh);
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.strokeRect(px, py, bw, bh);
      }

      if (z.mutation !== "none" && !z.isCloaked) {
        ctx.globalAlpha = 0.82;
        ctx.fillStyle = z.mutation === "blink" ? "#a855f7" : z.mutation === "dash" ? "#fb923c" : "#22d3ee";
        ctx.font = "700 11px ui-sans-serif, system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Mutant!", 0, -z.r*1.6);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
      return true;
    }

    function drawTurret(){
      if (Player.turretLevel <= 0) return;
      const x = State.w * 0.5;
      const y = State.h - 16;

      ctx.save();
      ctx.translate(x,y);

      // base
      ctx.fillStyle = "rgba(20,24,34,.92)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      drawRoundedRect(-24, -14, 48, 22, 10);
      ctx.fill(); ctx.stroke();

      // barrel
      ctx.fillStyle = "rgba(139,92,246,.85)";
      ctx.strokeStyle = "rgba(139,92,246,.35)";
      drawRoundedRect(-6, -26, 12, 18, 6);
      ctx.fill(); ctx.stroke();

      // glow
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "rgba(139,92,246,1)";
      ctx.beginPath();
      ctx.arc(0, -18, 10 + Player.turretLevel*1.2, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // ---------- Main update loop
    function update(dt){
      State.time += dt;

      // screen shake decay
      if (State.shakeT > 0) State.shakeT = Math.max(0, State.shakeT - dt);
      if (State.damageFlash > 0) State.damageFlash = Math.max(0, State.damageFlash - dt);

      if (State.hitStop > 0){
        State.hitStop = Math.max(0, State.hitStop - dt);
        return;
      }

      State.hpSmooth = lerp(State.hpSmooth, Player.hp, dt * 8);
      State.hpGhost = lerp(State.hpGhost, Player.hp, dt * 2.5);
      if (Combo.timer > 0){
        Combo.timer = Math.max(0, Combo.timer - dt);
        if (Combo.timer === 0) resetCombo(true);
      }
      updateComboUI();

      const currentTime = nowMs();
      const regenReady = State.mode !== "gameover" && (currentTime - Player.lastDamageAt) > REGEN_DELAY_MS && Player.hp < Player.maxHp;
      if (regenReady) {
        Player.hp = Math.min(Player.maxHp, Player.hp + REGEN_RATE * dt);
      }
      if (hpWrap) hpWrap.classList.toggle("regen", regenReady);

      // turret heat decay
      if (Player.turretHeat > 0) {
        Player.turretHeat = Math.max(0, Player.turretHeat - dt * 0.10);
      }

      if (State.mode !== "playing") { updateHUD(); return; }
      if (State.paused) return;

      for (const [pid, ps] of pointerState.entries()) {
        attemptShoot(pid, ps.x, ps.y);
      }

        // Spawn logic
        const t = nowMs();
        if (Wave.active && !Number.isFinite(Wave.nextSpawnAt)) {
          Wave.nextSpawnAt = t + 120;
        }
        if (Wave.active && Wave.isBossWave) {
          if (!Wave.bossSpawned && t >= Wave.nextSpawnAt) {
            spawnBoss();
            Wave.spawned++;
            Wave.bossSpawned = true;
            Wave.nextSpawnAt = t + Wave.spawnEveryMs;
          }
        } else if (Wave.active && Wave.spawned < Wave.toSpawn && t >= Wave.nextSpawnAt) {
          if (zombies.length >= MAX_Z) {
            Wave.nextSpawnAt = t + 160;
          } else {
            spawnZombie();
            Wave.spawned++;
            if (Wave.mood === "SWARM") {
              let extra = 0;
              const roll = Math.random();
              if (roll < 0.12) extra = 2; else if (roll < 0.47) extra = 1;
              for (let n=0; n<extra && Wave.spawned < Wave.toSpawn && zombies.length < MAX_Z; n++) {
                spawnZombie();
                Wave.spawned++;
              }
            }
            Wave.nextSpawnAt = t + Wave.spawnEveryMs * rand(0.72, 1.10);
          }
        }

      // Turret
      turretTryShoot();

      // Update zombies
      for (let i=zombies.length-1; i>=0; i--){
        const z = zombies[i];
        z.t += dt;
        if (z.invulnTimer > 0) z.invulnTimer = Math.max(0, z.invulnTimer - dt);
        if (z.blinkFlash > 0) z.blinkFlash = Math.max(0, z.blinkFlash - dt * 1.8);

        // bob + step
        const bobAmp = (z.type === "runner") ? 4.6 : (z.type === "tank") ? 2.9 : 3.6;
        z.step += dt * ((z.type === "runner") ? 10.0 : (z.type === "tank") ? 6.2 : 8.0);
        z.bob = Math.sin(z.t*8.2) * bobAmp;

        // mutation behaviors
        if (z.mutation === "blink") {
          z.nextBlink = z.nextBlink ?? rand(1.2, 2.0);
          z.nextBlink -= dt;
          if (z.nextBlink <= 0) {
            const shift = (Math.random() < 0.5 ? -1 : 1) * rand(40, 110);
            const marginX = 18;
            const newX = clamp(z.x + shift, marginX, State.w - marginX);
            if (Math.abs(newX - z.x) > 2) {
              addRing(newX, z.y, 14, 0.3);
              spawnParticles(newX, z.y, 6, 140);
            }
            z.x = newX;
            z.x0 = newX;
            z.invulnTimer = Math.max(z.invulnTimer, 0.18);
            z.blinkFlash = 0.25;
            z.nextBlink = rand(1.2, 2.0);
          }
        } else if (z.mutation === "cloak") {
          if (z.isCloaked) {
            z.cloakTimer -= dt;
            if (z.cloakTimer <= 0) {
              z.isCloaked = false;
              z.nextCloak = rand(1.8, 2.6);
            }
          } else {
            z.nextCloak = (z.nextCloak ?? rand(1.8, 2.6)) - dt;
            if (z.nextCloak <= 0) {
              z.isCloaked = true;
              z.cloakTimer = rand(0.6, 0.9);
              z.invulnTimer = Math.max(z.invulnTimer, 0.05);
            }
          }
        } else if (z.mutation === "dash") {
          if (z.dashTime > 0) {
            z.dashTime -= dt;
            if (z.dashTime <= 0) {
              z.dashMult = 1;
              z.nextDash = rand(1.6, 2.4);
            }
          } else {
            z.nextDash = (z.nextDash ?? rand(1.6, 2.4)) - dt;
            if (z.nextDash <= 0) {
              z.dashTime = rand(0.22, 0.27);
              z.dashMult = rand(2.2, 2.8);
              z.nextDash = rand(1.6, 2.4) + z.dashTime;
            }
          }
        }

        if (!Number.isFinite(z.x0)) z.x0 = z.x;
        if (!z.isBoss) {
          const wa = z.wiggleAmp || 0;
          if (wa > 0) {
            const osc = (z.wiggleMode === "tri")
              ? triWave(z.t * (z.wiggleFreq || 1) + (z.wigglePhase || 0))
              : Math.sin(z.t * (z.wiggleFreq || 1) + (z.wigglePhase || 0));
            const marginX = 18;
            z.x = clamp(z.x0 + osc * wa, marginX, State.w - marginX);
          }
        } else if (z.wiggleAmp > 0) {
          const osc = Math.sin(z.t * (z.wiggleFreq || 0.35) + (z.wigglePhase || 0));
          z.x = clamp(z.x0 + osc * z.wiggleAmp, 22, State.w - 22);
        }

        const speedBoost = (z.mutation === "dash" && z.dashTime > 0) ? z.dashMult : 1;
        z.y += z.vy * speedBoost * dt;
        if (z.y < State.playTop) z.y = State.playTop;

        if (z.hitT > 0) z.hitT = Math.max(0, z.hitT - dt);

        // sprite animation frame (if sheet exists)
        if (Assets.zombieSheetOk) {
          z.frameT += dt;
          const spd = (z.type === "runner") ? 0.09 : (z.type === "tank") ? 0.14 : 0.11;
          if (z.frameT >= spd) {
            z.frameT = 0;
            z.frame = (z.frame + 1) & 3;
          }
        }

        // Reached bottom: damage player and remove
        if (z.y - z.r > State.h + 6) {
          applyPlayerDamage(z.passDmg, true);
          // Remove zombie
          const last = zombies.length - 1;
          zombies[i] = zombies[last];
          zombies.pop();
        }
      }

        // Wave complete?
        if (State.mode === "playing" && Wave.active) {
          if (Wave.spawned >= Wave.toSpawn && zombies.length === 0) {
            waveCleared();
          }
          if (Wave.spawned < Wave.toSpawn && zombies.length === 0 && (t - Wave.nextSpawnAt) > 1500) {
            Wave.nextSpawnAt = t + 50;
          }
        }

      updateHUD();
    }

    function updateParticles(dt){
      // Particles
      for (let i=0;i<P_MAX;i++){
        let life = P.life[i];
        if (life <= 0) continue;
        life -= dt;
        P.life[i] = life;
        if (life <= 0) continue;

        P.vy[i] += 520 * dt; // gravity
        P.x[i]  += P.vx[i] * dt;
        P.y[i]  += P.vy[i] * dt;

        // mild drag
        P.vx[i] *= (1 - 0.8*dt);
        P.vy[i] *= (1 - 0.3*dt);
      }

      // Decals (fade)
      for (let i=0;i<decal.count;i++){
        if (decal.life[i] <= 0) continue;
        decal.life[i] -= dt;
      }

      // Shots
      for (let i=0;i<SHOT_MAX;i++){
        if (Shots.life[i] <= 0) continue;
        Shots.life[i] -= dt;
      }

      // Floating text
      for (let i=0;i<FT_MAX;i++){
        const ft = FT[i];
        if (ft.life <= 0) continue;
        ft.life -= dt;
        ft.y += ft.vy * dt;
      }

      // Rings
      for (let i=0;i<R_MAX;i++){
        if (Rings.life[i] <= 0) continue;
        Rings.life[i] -= dt;
      }

      // Reticles
      for (let i=0;i<RET_MAX;i++){
        if (Ret.life[i] <= 0) continue;
        Ret.life[i] -= dt;
      }
    }

    // ---------- Drawing
    function draw(){
      // Clear
      ctx.clearRect(0,0,State.w,State.h);

      // Screen shake transform
      ctx.save();
      if (State.shakeT > 0) {
        const t = State.shakeT;
        const mag = State.shakeMag * (t/0.18);
        ctx.translate(rand(-mag, mag), rand(-mag, mag));
      }

      // Subtle ground line near bottom
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, State.h - 8);
      ctx.lineTo(State.w, State.h - 8);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Blood decals (if image present)
      if (Assets.bloodOk && decal.count > 0) {
        for (let i=0;i<decal.count;i++){
          const life = decal.life[i];
          if (life <= 0) continue;
          const t = clamp(life / decal.max[i], 0, 1);
          const a = decal.a[i] * t;
          const size = lerp(44, 56, 1 - t);
          const cell = decal.cell[i] || 0;
          const atlas = Assets.bloodAtlas;
          const sx = (cell % atlas.cols) * atlas.cellW;
          const sy = Math.floor(cell / atlas.cols) * atlas.cellH;

          ctx.save();
          ctx.translate(decal.x[i], decal.y[i]);
          ctx.rotate(decal.rot[i]);
          ctx.globalAlpha = a;
          ctx.drawImage(Assets.blood, sx, sy, atlas.cellW, atlas.cellH, -size/2, -size/2, size, size);
          ctx.restore();
        }
      }

      // Turret
      drawTurret();

      // Zombies
      for (let i=0;i<zombies.length;i++){
        const z = zombies[i];
        if (Assets.zombieSheetOk) {
          // Use sprite if possible, else fallback procedural
          const ok = drawZombieSprite(z);
          if (!ok) drawZombieProcedural(z);
        } else {
          drawZombieProcedural(z);
        }
      }

      // Shots
      for (let i=0;i<SHOT_MAX;i++){
        const life = Shots.life[i];
        if (life <= 0) continue;
        const tLife = clamp(life / Shots.max[i], 0, 1);
        const t = 1 - tLife;
        const x1 = Shots.x1[i], y1 = Shots.y1[i];
        const x2 = Shots.x2[i], y2 = Shots.y2[i];
        const px = lerp(x1, x2, t);
        const py = lerp(y1, y2, t);

        ctx.globalAlpha = tLife * 0.7;
        ctx.strokeStyle = "rgba(139,92,246,.85)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // moving projectile dot
        ctx.globalAlpha = clamp(0.35 + (1 - tLife)*0.65, 0, 1);
        ctx.fillStyle = "rgba(255,255,255,.95)";
        ctx.beginPath();
        ctx.arc(px, py, 2.6, 0, Math.PI*2);
        ctx.fill();

        // muzzle flash
        const flash = Math.max(0, 0.5 - t*2.2);
        if (flash > 0) {
          ctx.globalAlpha = flash * 0.65;
          ctx.fillStyle = "rgba(255,255,255,.9)";
          ctx.beginPath();
          ctx.arc(x1, y1, 6 + flash*6, 0, Math.PI*2);
          ctx.fill();
        }

        // tiny impact shimmer
        ctx.globalAlpha = Math.max(0, (1 - t) * 0.4);
        ctx.strokeStyle = "rgba(255,255,255,.55)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.arc(x2, y2, 6 + (1-tLife)*4, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Particles
      for (let i=0;i<P_MAX;i++){
        const life = P.life[i];
        if (life <= 0) continue;
        const t = clamp(life / P.max[i], 0, 1);
        const a = t * 0.9;

        ctx.globalAlpha = a;
        // HSL without expensive strings? (strings are fine at this scale, but we keep it simple)
        const hue = P.hue[i];
        ctx.fillStyle = `hsla(${hue}, 90%, 55%, ${a})`;

        const s = P.size[i];
        ctx.beginPath();
        ctx.arc(P.x[i], P.y[i], s, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Rings
      for (let i=0;i<R_MAX;i++){
        const life = Rings.life[i];
        if (life <= 0) continue;
        const t = clamp(life / Rings.max[i], 0, 1);
        ctx.globalAlpha = t*0.5;
        ctx.strokeStyle = `rgba(255,255,255,${0.6*t})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(Rings.x[i], Rings.y[i], Rings.r[i]*(1+(1-t)*1.4), 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Tap reticles
      for (let i=0;i<RET_MAX;i++){
        const life = Ret.life[i];
        if (life <= 0) continue;
        const t = clamp(life / Ret.max[i], 0, 1);
        ctx.globalAlpha = t*0.6;
        ctx.strokeStyle = "rgba(139,92,246,.7)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(Ret.x[i], Ret.y[i], 18*(1-t), 0, Math.PI*2);
        ctx.stroke();
      }

      // Floating text
      ctx.font = "700 14px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      for (let i=0;i<FT_MAX;i++){
        const ft = FT[i];
        if (ft.life <= 0) continue;
        const t = clamp(ft.life / ft.max, 0, 1);
        ctx.globalAlpha = t;
        ctx.fillStyle = ft.color;
        ctx.fillText(ft.text, ft.x, ft.y);
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      // Damage flash overlay (no transform)
      if (State.damageFlash > 0) {
        const a = clamp(State.damageFlash / 0.22, 0, 1) * 0.25;
        ctx.fillStyle = `rgba(239,68,68,${a})`;
        ctx.fillRect(0,0,State.w,State.h);
      }

      // Start hint while in start mode (canvas-only hint behind overlay is fine)
      if (State.mode === "playing") {
        // small bottom hint if no turret yet (only early waves)
        if (Wave.num <= 2 && Player.turretLevel === 0) {
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = "rgba(255,255,255,.9)";
          ctx.font = "700 12px ui-sans-serif, system-ui";
          ctx.textAlign = "center";
          ctx.fillText("Tip: Buy a turret between waves üõí", State.w/2, State.h - 36);
          ctx.globalAlpha = 1;
        }
      }
    }

    // ---------- Loop
    function loop(){
      const t = nowMs();
      const dt = clamp((t - State.lastT) / 1000, 0, 0.033);
      State.lastT = t;

      update(dt);
      updateParticles(dt);
      draw();

      requestAnimationFrame(loop);
    }

    // ---------- Start / Shop UI setup text
    function setStartOverlay(){
      overlayTitle.textContent = "Tap to start";
      overlayDesc.innerHTML = `Your first tap will also unlock audio on mobile. Survive as many waves as you can.<br>Banked coins: <b>${Save.coinsBank}</b> ¬∑ Upgrades: dmg ${Save.dmgLevel}, rate ${Save.rateLevel}, turret ${Save.turretLevel}, multi ${Save.multishotLevel||0}, expl ${Save.explosiveLevel||0}, shield ${Save.shieldLevel||0}`;
      startBtn.textContent = "Start";
      mainOverlay.classList.remove("hidden");
      shopOverlay.classList.add("hidden");
      State.mode = "start";
    }

    // ---------- Passive ‚Äúenter shop‚Äù helper (when wave clears)
    function closeIfOpen(el){
      if (!el.classList.contains("hidden")) el.classList.add("hidden");
    }

    // ---------- Initialize
    function init(){
      resize();
      setStartOverlay();
      updateHUD();
      updateSettingsUI();

      // Keep canvas properly sized
      // (call once more after layout settles)
      setTimeout(resize, 50);

      requestAnimationFrame(loop);
    }

    init();
  })();
  </script>
</body>
</html>
