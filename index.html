<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Zombie Tap Defense</title>
  <style>
    :root{
      --bg:#0b0d12;
      --panel:rgba(18,22,32,.86);
      --panel2:rgba(12,14,20,.78);
      --text:#e7eaf0;
      --muted:#9aa3b2;
      --accent:#8b5cf6;
      --good:#22c55e;
      --bad:#ef4444;
      --line:rgba(255,255,255,.08);
      --shadow:0 12px 30px rgba(0,0,0,.35);
      --hud-glow:0 8px 24px rgba(139,92,246,.25);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 50% -10%, rgba(139,92,246,.18), transparent 60%),
                  radial-gradient(900px 700px at 90% 20%, rgba(34,197,94,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-tap-highlight-color: transparent;
    }

    #root{
      position:fixed; inset:0;
      display:flex; flex-direction:column;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* HUD */
    #hud{
      position:absolute;
      left:0; right:0; top:0;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 10px calc(10px + env(safe-area-inset-top));
      background: linear-gradient(to bottom, rgba(10,12,18,.92), rgba(10,12,18,.55), transparent);
      pointer-events:none;
      z-index:10;
    }
    #hud .left, #hud .right{
      display:flex; align-items:center; gap:10px;
      pointer-events:none;
      flex-wrap:wrap;
    }
    #hud .pill, #hud .stat, #hud .divider, #hud .hpBar, #hud .hpWrap, #hud .hpText{pointer-events:none;}
    #hud .right{pointer-events:auto;}
    #hud button{pointer-events:auto;}
    .pill{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 10px;
      box-shadow: var(--shadow);
      display:flex; align-items:center; gap:10px;
      min-height:38px;
      backdrop-filter: blur(6px);
    }
    .stat{
      display:flex; flex-direction:column; line-height:1.05;
      gap:2px;
    }
    .stat .k{font-size:11px; color:var(--muted)}
    .stat .v{font-size:13px; font-weight:700}
    .divider{width:1px; height:18px; background:var(--line)}
    .btn{
      pointer-events:auto;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{background: rgba(255,255,255,.09)}
    .btn:active{transform: translateY(1px) scale(.99)}
    .btn.primary{
      background: linear-gradient(135deg, rgba(139,92,246,.85), rgba(139,92,246,.45));
      border-color: rgba(139,92,246,.55);
    }
    .btn.good{
      background: linear-gradient(135deg, rgba(34,197,94,.8), rgba(34,197,94,.35));
      border-color: rgba(34,197,94,.5);
    }
    .btn.bad{
      background: linear-gradient(135deg, rgba(239,68,68,.8), rgba(239,68,68,.35));
      border-color: rgba(239,68,68,.5);
    }
    .btn.small{padding:8px 10px; border-radius:999px; font-size:13px}

    /* Health bar */
    .hpWrap{display:flex; align-items:center; gap:10px; position:relative; padding-right:8px; box-shadow:var(--hud-glow)}
    .hpBar{
      width:200px; height:16px; border-radius:12px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.09);
      overflow:hidden;
      position:relative;
    }
    .hpFill{
      height:100%;
      width:100%;
      background: linear-gradient(90deg, rgba(34,197,94,.95), rgba(34,197,94,.55));
      border-right:1px solid rgba(255,255,255,.18);
      transform-origin:left center;
      transition: background .2s linear;
    }
    .hpGhost{
      position:absolute; left:0; top:0; height:100%; width:100%;
      background: linear-gradient(90deg, rgba(255,255,255,.16), rgba(255,255,255,.05));
      pointer-events:none;
      transform-origin:left center;
    }
    .hpText{font-size:12px; color:var(--muted); font-weight:700}
    .waveProg{width:180px; height:10px; border-radius:999px; background:rgba(255,255,255,.07); border:1px solid rgba(255,255,255,.08); overflow:hidden; position:relative;}
    .waveFill{position:absolute; left:0; top:0; height:100%; width:0%; background: linear-gradient(90deg, rgba(139,92,246,.85), rgba(94,234,212,.8)); box-shadow: 0 2px 10px rgba(139,92,246,.35);}
    .tag{font-size:11px; color:var(--muted); font-weight:800; letter-spacing:.5px; text-transform:uppercase;}
    .pauseBtn{padding:9px 10px; border-radius:12px; min-width:46px;}

    /* Canvas */
    #gameCanvas{
      width:100%;
      height:100%;
      display:block;
      touch-action:none; /* important: pointer events without scroll/zoom */
      user-select:none;
      -webkit-user-select:none;
      background: radial-gradient(900px 700px at 50% 15%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(1000px 750px at 50% 110%, rgba(139,92,246,.08), transparent 60%);
    }

    /* Overlays */
    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
      z-index:30;
      background: radial-gradient(900px 650px at 50% 30%, rgba(0,0,0,.55), rgba(0,0,0,.72));
      backdrop-filter: blur(6px);
    }
    .hidden{display:none !important}
    .card{
      width:min(520px, 100%);
      background: rgba(14,16,24,.78);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      box-shadow: 0 22px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .card header{
      padding:16px 16px 10px 16px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
    }
    .title{
      font-size:20px; font-weight:900; margin:0 0 6px 0;
      letter-spacing:.2px;
    }
    .subtitle{margin:0; color:var(--muted); font-size:13px; line-height:1.35}
    .card .content{padding:14px 16px 16px 16px}
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.04);
      border-radius:14px;
    }
    .row .meta{display:flex; flex-direction:column; gap:3px}
    .row .meta .name{font-weight:900}
    .row .meta .desc{font-size:12px; color:var(--muted)}
    .price{font-size:12px; color:var(--muted); font-weight:800}
    .footerActions{
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      margin-top:12px;
    }
    .tiny{
      font-size:12px; color:var(--muted); line-height:1.35;
    }
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      font-weight:800;
      font-size:11px;
      color:rgba(255,255,255,.85);
    }

    /* Small toast */
    #toast{
      position:absolute;
      left:50%; bottom:18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 12px;
      font-weight:800;
      font-size:13px;
      color:rgba(255,255,255,.92);
      box-shadow: 0 12px 28px rgba(0,0,0,.45);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      z-index:40;
    }
    #toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }

    /* Vignette + vignette pulse */
    #vignette{
      position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(120% 95% at 50% 50%, rgba(0,0,0,0), rgba(0,0,0,.55));
      opacity:0; transition: opacity .25s ease;
      z-index:8;
    }

    /* Settings panel */
    #settingsPanel{
      position:absolute; right:12px; top:56px;
      background: var(--panel2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      box-shadow: var(--shadow);
      min-width:200px;
      z-index:20;
    }
    #settingsPanel.hidden{display:none;}
    .settingRow{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0; font-size:13px;}
    .settingRow label{color:var(--muted); font-weight:700;}
    .toggle{width:42px; height:22px; border-radius:999px; background:rgba(255,255,255,.16); border:1px solid var(--line); position:relative; cursor:pointer;}
    .toggle .dot{position:absolute; width:18px; height:18px; border-radius:50%; background:#fff; top:1px; left:1px; transition: transform .18s ease;}
    .toggle.on{background:rgba(139,92,246,.55); border-color:rgba(139,92,246,.6);} 
    .toggle.on .dot{transform: translateX(20px);}
  </style>
</head>
<body>
    <div id="root">
    <div id="vignette"></div>
      <canvas id="gameCanvas"></canvas>

    <div id="hud">
      <div class="left">
        <div class="pill hpWrap">
          <div class="stat">
            <div class="k">Health</div>
            <div class="v" id="hpLabel">100</div>
          </div>
          <div class="hpBar" aria-label="Health bar">
            <div class="hpFill" id="hpFill"></div>
            <div class="hpGhost" id="hpGhost"></div>
          </div>
          <div class="hpText" id="hpPct">100%</div>
        </div>

        <div class="pill">
          <div class="stat">
            <div class="k">Bank</div>
            <div class="v" id="coinLabel">0</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Wave</div>
            <div class="v" id="waveLabel">0</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Score</div>
            <div class="v" id="scoreLabel">0</div>
          </div>
        </div>

        <div class="pill">
          <div class="stat">
            <div class="k">Wave Prog</div>
            <div class="v" id="waveProgressLabel">0/0</div>
          </div>
          <div class="waveProg" aria-label="Wave progress">
            <div class="waveFill" id="waveFill"></div>
          </div>
        </div>

        <div class="pill">
          <div class="stat">
            <div class="k">Tap Dmg</div>
            <div class="v" id="dmgLabel">1</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Fire Rate</div>
            <div class="v" id="rateLabel">3.3/s</div>
          </div>
          <div class="divider"></div>
          <div class="stat">
            <div class="k">Turret</div>
            <div class="v" id="turretLabel">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="right">
        <button class="btn small pauseBtn" id="pauseBtn" title="Pause">‚è∏Ô∏è</button>
        <button class="btn small" id="soundBtn" title="Toggle sound">üîä Sound</button>
        <button class="btn small" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div id="settingsPanel" class="hidden">
      <div class="settingRow"><label>Sound</label><div class="toggle" data-setting="sound"><div class="dot"></div></div></div>
      <div class="settingRow"><label>Vibration</label><div class="toggle" data-setting="vibration"><div class="dot"></div></div></div>
      <div class="settingRow"><label>Reduce motion</label><div class="toggle" data-setting="motion"><div class="dot"></div></div></div>
      <button class="btn bad" id="resetProgressSmall" style="width:100%; margin-top:8px">Reset Progress</button>
    </div>

    <!-- Start / Game Over overlay -->
    <div id="mainOverlay" class="overlay">
      <div class="card">
        <header>
          <h1 class="title">üßü Zombie Tap Defense</h1>
          <p class="subtitle">
            Tap zombies to shoot. Survive waves. Buy upgrades between waves.
            <br><span class="kbd">Touch / Mouse</span> ¬∑ <span class="kbd">No build tools</span> ¬∑ <span class="kbd">GitHub Pages</span>
          </p>
        </header>
        <div class="content">
          <div class="grid">
            <div class="row">
              <div class="meta">
                <div class="name">Best Wave</div>
                <div class="desc" id="bestWaveLabel">0</div>
              </div>
              <div class="meta">
                <div class="name">Best Score</div>
                <div class="desc" id="bestScoreLabel">0</div>
              </div>
            </div>
            <div class="row">
              <div class="meta">
                <div class="name" id="overlayTitle">Tap to start</div>
                <div class="desc" id="overlayDesc">Your first tap will also unlock audio on mobile.</div>
              </div>
              <div class="footerActions">
                <button class="btn primary" id="startBtn">Start</button>
                <button class="btn" id="resetProgress">Reset Progress</button>
                <button class="btn" id="openSettingsFromStart">Settings</button>
              </div>
            </div>
            <p class="tiny">
              Assets are optional. If you add them later, put files here:
              <span class="kbd">/assets/zombie_sheet.png</span> (4 frames),
              <span class="kbd">/assets/blood.png</span>,
              <span class="kbd">/assets/hit.wav</span> <span class="kbd">kill.wav</span> <span class="kbd">hurt.wav</span> <span class="kbd">wave.wav</span>.
              The game still runs fine if they‚Äôre missing.
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Shop overlay (between waves) -->
    <div id="shopOverlay" class="overlay hidden">
      <div class="card">
        <header>
          <h2 class="title">üõí Wave cleared</h2>
          <p class="subtitle">Spend coins, then start the next wave.</p>
        </header>
        <div class="content">
          <div class="grid">
            <div class="row">
              <div class="meta">
                <div class="name">Upgrade Damage</div>
                <div class="desc" id="dmgDesc">Increase tap damage.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costDmg">‚Äî</div>
                <button class="btn primary" id="buyDmg">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Upgrade Fire Rate</div>
                <div class="desc" id="rateDesc">Shoot faster (reduces cooldown).</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costRate">‚Äî</div>
                <button class="btn primary" id="buyRate">Buy</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Turret</div>
                <div class="desc" id="turretDesc">Auto-shoots nearest zombie from bottom-center.</div>
              </div>
              <div class="meta" style="text-align:right">
                <div class="price" id="costTurret">‚Äî</div>
                <button class="btn good" id="buyTurret">Buy / Upgrade</button>
              </div>
            </div>

            <div class="row">
              <div class="meta">
                <div class="name">Stats</div>
                <div class="desc" id="shopStats">‚Äî</div>
              </div>
              <div class="footerActions">
                <button class="btn" id="restartBtn">Restart</button>
                <button class="btn good" id="nextWaveBtn">Start next wave</button>
              </div>
            </div>

            <p class="tiny">
              Tip: hits are forgiving (big tap radius). Runners are fast. Tanks are chunky.
              If a zombie reaches the bottom edge, you take damage and it disappears.
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Pause overlay -->
    <div id="pauseOverlay" class="overlay hidden">
      <div class="card">
        <header>
          <h2 class="title">Paused</h2>
          <p class="subtitle">Take a breather.</p>
        </header>
        <div class="content">
          <div class="footerActions">
            <button class="btn primary" id="resumeBtn">Resume</button>
            <button class="btn" id="pauseSettings">Settings</button>
            <button class="btn bad" id="pauseRestart">Restart run</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Continue overlay -->
    <div id="continueOverlay" class="overlay hidden">
      <div class="card">
        <header>
          <h2 class="title">You were overwhelmed</h2>
          <p class="subtitle" id="summarySubtitle">Choose: revive or restart.</p>
        </header>
        <div class="content">
          <div class="row">
            <div class="meta">
              <div class="name">Wave reached</div>
              <div class="desc" id="summaryWave">0</div>
            </div>
            <div class="meta">
              <div class="name">Score</div>
              <div class="desc" id="summaryScore">0</div>
            </div>
            <div class="meta">
              <div class="name">Total kills</div>
              <div class="desc" id="summaryKills">0</div>
            </div>
          </div>
          <div class="row">
            <div class="meta">
              <div class="name">Best</div>
              <div class="desc" id="summaryBest">0</div>
            </div>
            <div class="meta">
              <div class="name">Bank</div>
              <div class="desc" id="summaryBank">0</div>
            </div>
          </div>
          <div class="footerActions">
            <button class="btn primary" id="reviveBtn">Continue (revive)</button>
            <button class="btn" id="restartWave1">Restart wave 1</button>
            <button class="btn bad" id="resetFromGameOver">Reset Progress</button>
          </div>
        </div>
      </div>
    </div>

    <div id="toast">Toast</div>
  </div>

  <script>
  (() => {
    "use strict";

    /* =========================================================
       Zombie Tap Defense ‚Äî single-file canvas game
       - Canvas + vanilla JS
       - Pointer events (touch + mouse)
       - HiDPI scaling (devicePixelRatio)
       - requestAnimationFrame loop
       - Optional assets with graceful fallback
       ========================================================= */

    // ---------- DOM
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d", { alpha: true });
    const hud = document.getElementById("hud");

    const hpLabel = document.getElementById("hpLabel");
    const hpFill  = document.getElementById("hpFill");
    const hpGhost = document.getElementById("hpGhost");
    const hpPct   = document.getElementById("hpPct");
    const coinLabel = document.getElementById("coinLabel");
    const waveLabel = document.getElementById("waveLabel");
    const scoreLabel = document.getElementById("scoreLabel");
    const dmgLabel = document.getElementById("dmgLabel");
    const rateLabel = document.getElementById("rateLabel");
    const turretLabel = document.getElementById("turretLabel");
    const waveFillEl = document.getElementById("waveFill");
    const waveProgressLabel = document.getElementById("waveProgressLabel");

    const soundBtn = document.getElementById("soundBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    const resetProgressSmall = document.getElementById("resetProgressSmall");
    const settingsToggles = settingsPanel.querySelectorAll('.toggle');

    function updateSettingsUI(){
      settingsToggles.forEach(t => {
        const key = t.dataset.setting;
        let on = false;
        if (key === "sound") on = Save.settings.soundOn !== false;
        if (key === "vibration") on = !!Save.settings.vibrationOn;
        if (key === "motion") on = !!Save.settings.reduceMotionOn;
        t.classList.toggle('on', on);
      });
    }

    function toggleSettingsPanel(forceOpen=false){
      const open = forceOpen ? true : settingsPanel.classList.contains("hidden");
      if (open){
        updateSettingsUI();
        settingsPanel.classList.remove("hidden");
      } else {
        settingsPanel.classList.add("hidden");
      }
    }

    const mainOverlay = document.getElementById("mainOverlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayDesc = document.getElementById("overlayDesc");
    const startBtn = document.getElementById("startBtn");
    const openSettingsFromStart = document.getElementById("openSettingsFromStart");
    const resetProgressBtn = document.getElementById("resetProgress");

    const shopOverlay = document.getElementById("shopOverlay");
    const costDmg = document.getElementById("costDmg");
    const costRate = document.getElementById("costRate");
    const costTurret = document.getElementById("costTurret");
    const buyDmg = document.getElementById("buyDmg");
    const buyRate = document.getElementById("buyRate");
    const buyTurret = document.getElementById("buyTurret");
    const nextWaveBtn = document.getElementById("nextWaveBtn");
    const restartBtn = document.getElementById("restartBtn");
    const shopStats = document.getElementById("shopStats");
    const dmgDesc = document.getElementById("dmgDesc");
    const rateDesc = document.getElementById("rateDesc");
    const turretDesc = document.getElementById("turretDesc");

    const pauseOverlay = document.getElementById("pauseOverlay");
    const resumeBtn = document.getElementById("resumeBtn");
    const pauseSettingsBtn = document.getElementById("pauseSettings");
    const pauseRestartBtn = document.getElementById("pauseRestart");

    const continueOverlay = document.getElementById("continueOverlay");
    const reviveBtn = document.getElementById("reviveBtn");
    const restartWave1Btn = document.getElementById("restartWave1");
    const resetFromGameOverBtn = document.getElementById("resetFromGameOver");
    const summaryWave = document.getElementById("summaryWave");
    const summaryScore = document.getElementById("summaryScore");
    const summaryKills = document.getElementById("summaryKills");
    const summaryBest = document.getElementById("summaryBest");
    const summaryBank = document.getElementById("summaryBank");
    const summarySubtitle = document.getElementById("summarySubtitle");

    const vignette = document.getElementById("vignette");

    const bestWaveLabel = document.getElementById("bestWaveLabel");
    const bestScoreLabel = document.getElementById("bestScoreLabel");
    const toastEl = document.getElementById("toast");

    // ---------- Utilities
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const rand  = (a, b) => a + Math.random() * (b - a);
    const randi = (a, b) => (a + Math.floor(Math.random() * (b - a + 1)));
    const nowMs = () => performance.now();
    const fmt = (n) => Math.floor(n).toString();

    function showToast(msg) {
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.remove("show"), 900);
    }

    // ---------- Save System
    const SAVE_KEY = "ztd_save_v2";
    const defaultSave = () => ({
      coinsBank: 0,
      dmgLevel: 0,
      rateLevel: 0,
      turretLevel: 0,
      bestWave: 0,
      bestScore: 0,
      totalKills: 0,
      runs: 0,
      settings: {
        soundOn: true,
        vibrationOn: false,
        reduceMotionOn: false,
      },
    });

    function loadSave(){
      let save = defaultSave();
      try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (raw) Object.assign(save, JSON.parse(raw));
      } catch (e) {}

      // migrate old bests
      const oldWave = +localStorage.getItem("ztd_bestWave") || 0;
      const oldScore = +localStorage.getItem("ztd_bestScore") || 0;
      save.bestWave = Math.max(save.bestWave || 0, oldWave);
      save.bestScore = Math.max(save.bestScore || 0, oldScore);
      persistSave(save);
      return save;
    }

    function persistSave(s=Save){
      localStorage.setItem(SAVE_KEY, JSON.stringify(s));
    }

    function resetProgress(){
      localStorage.removeItem(SAVE_KEY);
      localStorage.removeItem("ztd_bestWave");
      localStorage.removeItem("ztd_bestScore");
      Save = loadSave();
      applySaveToPlayer();
      updateHUD();
      setStartOverlay();
      showToast("Progress reset");
      continueOverlay.classList.add("hidden");
      pauseOverlay.classList.add("hidden");
    }

    let Save = loadSave();

    // ---------- Optional assets (images + sounds)
    const Assets = {
      zombieSheet: null,
      zombieSheetOk: false,
      blood: null,
      bloodOk: false,
      bloodAtlas: { cols:2, rows:2, cellW:0, cellH:0 },
    };

    function colorKeyToCanvas(img, tolerance=18){
      const c = document.createElement('canvas');
      c.width = img.width; c.height = img.height;
      const g = c.getContext('2d');
      g.drawImage(img,0,0);
      const data = g.getImageData(0,0,c.width,c.height);
      const d = data.data;
      const r0=d[0], g0=d[1], b0=d[2];
      const tol = tolerance*3;
      for (let i=0;i<d.length;i+=4){
        const dr=Math.abs(d[i]-r0)+Math.abs(d[i+1]-g0)+Math.abs(d[i+2]-b0);
        if (dr < tol) d[i+3]=0;
      }
      g.putImageData(data,0,0);
      return c;
    }

    function loadImage(url) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ ok:true, img });
        img.onerror = () => resolve({ ok:false, img:null });
        img.src = url;
      });
    }

    // Preload optional images (safe even if missing)
    Promise.all([
      loadImage("assets/zombie_sheet.png"),
      loadImage("assets/blood.png"),
    ]).then(([zs, bl]) => {
      if (zs.ok) { Assets.zombieSheet = colorKeyToCanvas(zs.img); Assets.zombieSheetOk = true; }
      if (bl.ok) {
        const c = colorKeyToCanvas(bl.img);
        Assets.blood = c; Assets.bloodOk = true;
        Assets.bloodAtlas.cellW = c.width / Assets.bloodAtlas.cols;
        Assets.bloodAtlas.cellH = c.height / Assets.bloodAtlas.rows;
      }
    });

    // ---------- Sound manager (WebAudio with unlock + optional file buffers)
    const Sound = (() => {
      let enabled = true;
      let unlocked = false;
      let ctxA = null;
      let master = null;
      const buffers = new Map();
      const sfxGains = { hit:0.30, kill:0.55, hurt:0.45, wave:0.40, ui:0.30 };

      // Optional sound files
      const soundFiles = {
        hit:  "assets/hit.wav",
        kill: "assets/kill.wav",
        hurt: "assets/hurt.wav",
        wave: "assets/wave.wav",
        ui:   "assets/ui.wav",
      };

      function setEnabled(v) {
        enabled = !!v;
        soundBtn.textContent = enabled ? "üîä Sound" : "üîá Muted";
        Save.settings.soundOn = enabled;
        persistSave();
        updateSettingsUI();
      }

      function getEnabled() { return enabled; }

      async function unlock() {
        if (unlocked) return;
        try {
          ctxA = new (window.AudioContext || window.webkitAudioContext)();
          master = ctxA.createGain();
          master.gain.value = 0.30;
          master.connect(ctxA.destination);
          await ctxA.resume();
          unlocked = true;

          // Try loading optional audio buffers (graceful if missing)
          for (const [name, url] of Object.entries(soundFiles)) {
            fetch(url).then(r => {
              if (!r.ok) throw new Error("missing");
              return r.arrayBuffer();
            }).then(ab => ctxA.decodeAudioData(ab))
              .then(buf => buffers.set(name, buf))
              .catch(() => {/* missing is fine */});
          }
        } catch (e) {
          // If WebAudio fails, just silently disable sound.
          enabled = false;
          soundBtn.textContent = "üîá Muted";
        }
      }

      function playBuffer(name, gain = 1) {
        if (!enabled || !unlocked || !ctxA || !master) return false;
        const buf = buffers.get(name);
        if (!buf) return false;
        const src = ctxA.createBufferSource();
        const g = ctxA.createGain();
        const mul = sfxGains[name] ?? 1;
        g.gain.value = clamp(gain * mul, 0, 2);
        src.buffer = buf;
        if (name === "hit" || name === "kill") src.playbackRate.value = rand(0.97, 1.03);
        src.connect(g);
        g.connect(master);
        src.start();
        return true;
      }

      // Fallback beeps (simple + mobile friendly)
      function beep({ f=440, dur=0.06, type="square", gain=0.18, slide=0 } = {}) {
        if (!enabled || !unlocked || !ctxA || !master) return;
        const o = ctxA.createOscillator();
        const g = ctxA.createGain();
        o.type = type;
        o.frequency.setValueAtTime(f, ctxA.currentTime);
        if (slide !== 0) {
          o.frequency.exponentialRampToValueAtTime(Math.max(40, f + slide), ctxA.currentTime + dur);
        }
        g.gain.setValueAtTime(0.0001, ctxA.currentTime);
        g.gain.exponentialRampToValueAtTime(gain, ctxA.currentTime + 0.008);
        g.gain.exponentialRampToValueAtTime(0.0001, ctxA.currentTime + dur);

        o.connect(g);
        g.connect(master);
        o.start();
        o.stop(ctxA.currentTime + dur + 0.01);
      }

      function play(name) {
        if (!enabled) return;
        // Try asset buffer, else fallback beep
        const ok = playBuffer(name, 1);
        if (ok) return;

        if (name === "hit")  beep({ f: 520, dur: 0.04, type:"square", gain:0.10, slide:-80 });
        if (name === "kill") beep({ f: 220, dur: 0.08, type:"sawtooth", gain:0.13, slide: 240 });
        if (name === "hurt") beep({ f: 120, dur: 0.10, type:"triangle", gain:0.17, slide:-30 });
        if (name === "wave") beep({ f: 660, dur: 0.12, type:"square", gain:0.10, slide: 200 });
        if (name === "ui")   beep({ f: 740, dur: 0.04, type:"square", gain:0.08, slide: 0 });
      }

      // Load persisted sound setting
      if (Save.settings && Save.settings.soundOn === false) enabled = false;

      setEnabled(enabled);

      return { unlock, play, setEnabled, getEnabled };
    })();

    // ---------- Game state
    const State = {
      mode: "start", // start | playing | shop | gameover | paused
      w: 0, h: 0, dpr: 1,
      playTop: 0,
      time: 0,
      lastT: nowMs(),
      shakeT: 0,
      shakeMag: 0,
      damageFlash: 0,
      hpSmooth: 100,
      hpGhost: 100,
      hitStop: 0,
      invulnUntil: 0,
      paused: false,
      reduceMotion: !!Save.settings.reduceMotionOn,
    };

    const Player = {
      maxHp: 120,
      hp: 120,
      coins: 0,
      score: 0,
      kills: 0,
      misses: 0,

      tapDamage: 1,
      tapCooldownMs: 300,
      lastTapShotAt: -1e9,

      dmgLevel: 0,
      rateLevel: 0,

      turretLevel: 0,
      turretCooldownMs: 900,
      turretLastShotAt: -1e9,
    };

    function recalcFromLevels(){
      Player.tapDamage = 1 + Player.dmgLevel;
      const base = 320;
      Player.tapCooldownMs = clamp(base * Math.pow(0.90, Player.rateLevel), 80, 320);
      Player.turretCooldownMs = clamp(900 * Math.pow(0.92, Math.max(0, Player.turretLevel-1)), 240, 900);
    }

    function applySaveToPlayer(){
      Player.coins = Save.coinsBank || 0;
      Player.dmgLevel = Save.dmgLevel || 0;
      Player.rateLevel = Save.rateLevel || 0;
      Player.turretLevel = Save.turretLevel || 0;
      recalcFromLevels();
    }

    const Combo = { value:0, timer:0 };

    const Wave = {
      num: 0,
      toSpawn: 0,
      spawned: 0,
      spawnEveryMs: 650,
      nextSpawnAt: 0,
      clearedAt: 0,
      active: false,
    };

    function updateBestLabels(){
      bestWaveLabel.textContent = String(Save.bestWave || 0);
      bestScoreLabel.textContent = String(Save.bestScore || 0);
    }
    updateBestLabels();
    applySaveToPlayer();
    State.hpSmooth = Player.hp;
    State.hpGhost = Player.hp;

    // ---------- Zombie types
    const ZOMBIE_TYPES = {
      normal: { name:"Normal", speed: 52, hp: 5,  coin: 4,  passDmg: 8,  r: 18 },
      runner: { name:"Runner", speed: 95, hp: 4,  coin: 5,  passDmg: 10, r: 16 },
      tank:   { name:"Tank",   speed: 38, hp: 14, coin: 9,  passDmg: 18, r: 22 },
    };

    // ---------- Entity pools
    const zombies = []; // small count, simple objects OK

    // Blood decals (stamps) ‚Äî fixed size ring buffer
    const DECAL_MAX = 64;
    const decal = {
      x: new Float32Array(DECAL_MAX),
      y: new Float32Array(DECAL_MAX),
      rot: new Float32Array(DECAL_MAX),
      cell: new Uint8Array(DECAL_MAX),
      life: new Float32Array(DECAL_MAX),
      max: new Float32Array(DECAL_MAX),
      a: new Float32Array(DECAL_MAX),
      idx: 0,
      count: 0,
    };

    // Particles ‚Äî fixed pool (avoid allocations during play)
    const P_MAX = 650;
    const P = {
      x: new Float32Array(P_MAX),
      y: new Float32Array(P_MAX),
      vx: new Float32Array(P_MAX),
      vy: new Float32Array(P_MAX),
      life: new Float32Array(P_MAX),
      max: new Float32Array(P_MAX),
      size: new Float32Array(P_MAX),
      hue: new Float32Array(P_MAX),
      idx: 0,
    };

    // Shot tracers (tap + turret)
    const SHOT_MAX = 80;
    const Shots = {
      x1: new Float32Array(SHOT_MAX),
      y1: new Float32Array(SHOT_MAX),
      x2: new Float32Array(SHOT_MAX),
      y2: new Float32Array(SHOT_MAX),
      life: new Float32Array(SHOT_MAX),
      max: new Float32Array(SHOT_MAX),
      idx: 0,
    };

    // Floating texts
    const FT_MAX = 48;
    const FT = Array.from({length:FT_MAX}, () => ({x:0,y:0,text:"",life:0,max:0,color:"#fff",vy:-28}));
    let ftIdx = 0;

    // Impact rings
    const R_MAX = 32;
    const Rings = {x:new Float32Array(R_MAX), y:new Float32Array(R_MAX), life:new Float32Array(R_MAX), max:new Float32Array(R_MAX), r:new Float32Array(R_MAX)};
    let ringIdx=0;

    // Tap reticles
    const RET_MAX = 16;
    const Ret = {x:new Float32Array(RET_MAX), y:new Float32Array(RET_MAX), life:new Float32Array(RET_MAX), max:new Float32Array(RET_MAX)};
    let retIdx=0;

    function spawnShot(x1,y1,x2,y2,ttl=0.08){
      const i = Shots.idx;
      Shots.x1[i]=x1; Shots.y1[i]=y1; Shots.x2[i]=x2; Shots.y2[i]=y2;
      Shots.life[i]=ttl; Shots.max[i]=ttl;
      Shots.idx = (Shots.idx+1) % SHOT_MAX;
      addRing(x1,y1,8,0.14);
      addRing(x2,y2,10,0.2);
    }

    function addFloatingText(x,y,text,color="#fff",life=0.9,vy=-22){
      const ft = FT[ftIdx];
      ft.x = x; ft.y = y; ft.text = text; ft.color = color; ft.life = life; ft.max = life; ft.vy = vy;
      ftIdx = (ftIdx+1) % FT_MAX;
    }

    function addRing(x,y,r=8,life=0.2){
      const i = ringIdx;
      Rings.x[i]=x; Rings.y[i]=y; Rings.r[i]=r; Rings.life[i]=life; Rings.max[i]=life;
      ringIdx = (ringIdx+1) % R_MAX;
    }

    function addReticle(x,y){
      const i = retIdx;
      Ret.x[i]=x; Ret.y[i]=y; Ret.max[i]=0.35; Ret.life[i]=0.35;
      retIdx = (retIdx+1) % RET_MAX;
    }

    function addDecal(x,y){
      const i = decal.idx;
      decal.x[i]=x; decal.y[i]=clamp(y, State.playTop + 4, State.h - 6);
      decal.rot[i]=rand(-0.25, 0.25);
      decal.cell[i]=randi(0, 3);
      decal.max[i]=rand(3.0, 5.0);
      decal.life[i]=decal.max[i];
      decal.a[i]=rand(0.55, 0.9);
      decal.idx = (decal.idx+1) % DECAL_MAX;
      decal.count = Math.min(DECAL_MAX, decal.count+1);
    }

    function spawnParticles(x,y,count,baseSpeed=180){
      // blood-ish burst with a touch of green/gray flecks
      for (let k=0;k<count;k++){
        const i = P.idx;
        const ang = rand(0, Math.PI*2);
        const sp  = baseSpeed * rand(0.35, 1.05);
        P.x[i]=x; P.y[i]=y;
        P.vx[i]=Math.cos(ang)*sp + rand(-18,18);
        P.vy[i]=Math.sin(ang)*sp + rand(-22,22);
        const ttl = rand(0.22, 0.65);
        P.max[i]=ttl; P.life[i]=ttl;
        P.size[i]=rand(1.4, 3.8);
        P.hue[i]=Math.random() < 0.83 ? rand(350, 10) : rand(95, 140); // mostly red, some sickly green
        P.idx = (P.idx+1) % P_MAX;
      }
    }

    // ---------- Resize / HiDPI handling
    function resize() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      State.dpr = dpr;

      const hudRect = hud.getBoundingClientRect();
      State.playTop = (hudRect?.height || 0) + 8;

      // Size canvas backing store
      const w = Math.max(320, Math.floor(rect.width));
      const h = Math.max(480, Math.floor(rect.height));
      State.w = w; State.h = h;

      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);

      // Scale drawing to CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize, { passive:true });

    // ---------- Input (pointer events, forgiving hit detection)
    let pointerDown = false;
    const pointerPos = {x:0,y:0};

    function canvasPointFromEvent(e){
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left);
      const y = (e.clientY - r.top);
      return { x, y };
    }

    function tryShootAt(x,y){
      const t = nowMs();
      // weapon cooldown
      if (t - Player.lastTapShotAt < Player.tapCooldownMs) return;

      Player.lastTapShotAt = t;
      addReticle(x,y);

      // Find closest zombie within forgiving radius
      let hitIdx = -1;
      let bestD2 = 1e18;
      for (let i=0;i<zombies.length;i++){
        const z = zombies[i];
        // forgiving hit radius
        const rr = z.r * 1.25;
        const dx = x - z.x;
        const dy = y - (z.y - z.bob*0.25);
        const d2 = dx*dx + dy*dy;
        if (d2 <= rr*rr && d2 < bestD2){
          bestD2 = d2;
          hitIdx = i;
        }
      }

      if (hitIdx === -1) {
        Player.misses++;
        Sound.play("hit"); // subtle "pew" even on miss? feels responsive
        // small spark particles (cheaper than separate pool)
        spawnParticles(x,y,6,90);
        addRing(x,y,10,0.25);
        return;
      }

      // Hit!
      const z = zombies[hitIdx];
      spawnShot(State.w*0.5, State.h - 18, z.x, z.y);
      z.hp -= Player.tapDamage;
      z.hitT = 0.12;
      addRing(z.x, z.y, 12, 0.25);
      State.hitStop = State.reduceMotion ? 0 : 0.025;
      Sound.play("hit");
      spawnParticles(x,y,12,140);

      if (z.hp <= 0) {
        // Kill
        Sound.play("kill");
        onZombieKilled(hitIdx);
      }
    }

    function onZombieKilled(index){
      const z = zombies[index];

      Player.kills++;
      Save.totalKills++;
      addCoins(z.coin, z.x, z.y);
      addFloatingText(z.x, z.y-10, `+${z.coin}c`, "#facc15", 1.0, -24);

      addCombo();
      const comboMult = 1 + Combo.value * 0.1;
      const bonus = Math.floor((10 + Wave.num * 3) * comboMult) + z.coin;
      Player.score += bonus;
      Save.bestScore = Math.max(Save.bestScore, Player.score);
      persistSave();

      // Big blood pop
      spawnParticles(z.x, z.y, randi(26, 36), 260);
      spawnParticles(z.x, z.y, 12, 90);
      addRing(z.x, z.y, 20, 0.35);
      State.hitStop = State.reduceMotion ? 0 : 0.055;
      State.shakeT = 0.18; State.shakeMag = 12;
      if (State.reduceMotion) State.shakeMag *= 0.5;
      if (navigator.vibrate && Save.settings.vibrationOn) navigator.vibrate(12);

      if (Assets.bloodOk) {
        addDecal(z.x, z.y + z.r*0.85);
      }

      // Remove zombie (swap-pop)
      const last = zombies.length - 1;
      zombies[index] = zombies[last];
      zombies.pop();
    }

    function applyPlayerDamage(amount){
      if (amount <= 0) return;
      if (nowMs() < State.invulnUntil) return;
      Player.hp = Math.max(0, Player.hp - amount);
      State.shakeT = 0.18;
      State.shakeMag = 9 + amount * 0.22;
      State.damageFlash = 0.35;
      if (State.reduceMotion) { State.shakeMag *= 0.5; State.damageFlash *= 0.6; }
      vignette.style.opacity = "0.32";
      resetCombo();
      if (navigator.vibrate && Save.settings.vibrationOn) navigator.vibrate([20,30,20]);
      Sound.play("hurt");

      if (Player.hp <= 0) {
        gameOver();
      }
    }

    // Prevent page scrolling while playing (extra safe for iOS)
    function preventMove(e){
      if (State.mode === "playing") e.preventDefault();
    }
    window.addEventListener("touchmove", preventMove, { passive:false });
    window.addEventListener("wheel", (e) => { if (State.mode === "playing") e.preventDefault(); }, { passive:false });

    canvas.addEventListener("pointerdown", (e) => {
      pointerDown = true;
      canvas.setPointerCapture?.(e.pointerId);

      const p = canvasPointFromEvent(e);
      pointerPos.x = p.x; pointerPos.y = p.y;

      // First interaction unlocks audio (iOS/Android requirement)
      Sound.unlock();

      if (State.mode === "start") {
        startGame();
        return;
      }
      if (State.mode !== "playing") return;

      tryShootAt(p.x, p.y);
    });

    canvas.addEventListener("pointerup", () => { pointerDown = false; });
    canvas.addEventListener("pointercancel", () => { pointerDown = false; });
    canvas.addEventListener("pointermove", (e) => {
      if (!pointerDown) return;
      const p = canvasPointFromEvent(e);
      pointerPos.x = p.x; pointerPos.y = p.y;
    });

    // ---------- UI buttons
    soundBtn.addEventListener("click", () => {
      Sound.unlock(); // allow unlocking via button too
      Sound.setEnabled(!Sound.getEnabled());
      Sound.play("ui");
    });

    settingsToggles.forEach(t => {
      t.addEventListener("click", () => {
        const key = t.dataset.setting;
        if (key === "sound") Sound.setEnabled(!Sound.getEnabled());
        if (key === "vibration") { Save.settings.vibrationOn = !Save.settings.vibrationOn; persistSave(); }
        if (key === "motion") { Save.settings.reduceMotionOn = !Save.settings.reduceMotionOn; State.reduceMotion = !!Save.settings.reduceMotionOn; persistSave(); }
        updateSettingsUI();
      });
    });

    pauseBtn.addEventListener("click", () => {
      if (State.mode !== "playing") return;
      State.paused = true;
      State.mode = "paused";
      pauseOverlay.classList.remove("hidden");
      Sound.play("ui");
    });

    resumeBtn.addEventListener("click", () => {
      if (State.mode !== "paused") return;
      State.paused = false;
      State.mode = "playing";
      pauseOverlay.classList.add("hidden");
      Sound.play("ui");
    });

    pauseRestartBtn.addEventListener("click", () => {
      Sound.play("ui");
      startGame();
    });

    pauseSettingsBtn.addEventListener("click", () => {
      toggleSettingsPanel();
    });

    settingsBtn.addEventListener("click", () => { toggleSettingsPanel(); });

    startBtn.addEventListener("click", () => {
      Sound.unlock();
      Sound.play("ui");
      startGame();
    });

    resetProgressBtn.addEventListener("click", () => { Sound.play("ui"); resetProgress(); });
    resetProgressSmall.addEventListener("click", () => { Sound.play("ui"); resetProgress(); });
    resetFromGameOverBtn.addEventListener("click", () => { Sound.play("ui"); resetProgress(); });
    openSettingsFromStart.addEventListener("click", () => { toggleSettingsPanel(true); });

    restartBtn.addEventListener("click", () => {
      Sound.play("ui");
      startGame();
    });

    nextWaveBtn.addEventListener("click", () => {
      Sound.play("wave");
      closeShopAndStartWave();
    });

    reviveBtn.addEventListener("click", () => { Sound.play("ui"); revivePlayer(); });
    restartWave1Btn.addEventListener("click", () => { Sound.play("ui"); startGame(); });

    buyDmg.addEventListener("click", () => {
      Sound.play("ui");
      const c = costDamage();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.dmgLevel++;
      Save.dmgLevel = Player.dmgLevel;
      recalcFromLevels();
      persistSave();
      showToast("Damage upgraded");
      updateShopUI();
    });

    buyRate.addEventListener("click", () => {
      Sound.play("ui");
      const c = costRateUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.rateLevel++;
      Save.rateLevel = Player.rateLevel;
      recalcFromLevels();
      persistSave();
      showToast("Fire rate upgraded");
      updateShopUI();
    });

    buyTurret.addEventListener("click", () => {
      Sound.play("ui");
      const c = costTurretUp();
      if (!spendCoins(c)) return showToast("Not enough coins");
      Player.turretLevel++;
      Save.turretLevel = Player.turretLevel;
      recalcFromLevels();
      persistSave();
      showToast(Player.turretLevel === 1 ? "Turret installed" : "Turret upgraded");
      updateShopUI();
    });

    // ---------- Costs (scale each purchase)
    function costDamage(){
      return Math.floor(30 * Math.pow(1.45, Player.dmgLevel));
    }
    function costRateUp(){
      return Math.floor(35 * Math.pow(1.55, Player.rateLevel));
    }
    function costTurretUp(){
      // first purchase is pricier, then scales
      const lvl = Player.turretLevel;
      const base = (lvl === 0) ? 80 : 65;
      return Math.floor(base * Math.pow(1.60, lvl));
    }

    function spendCoins(cost){
      if (Player.coins < cost) return false;
      Player.coins -= cost;
      Save.coinsBank = Player.coins;
      persistSave();
      return true;
    }

    function addCoins(amount,x=State.w*0.5,y=State.h*0.5){
      if (!amount) return;
      Player.coins += amount;
      Save.coinsBank = Player.coins;
      persistSave();
      addFloatingText(x,y,`+${amount}ü™ô`,`#facc15`,0.9,-26);
    }

    function addCombo(){
      Combo.timer = 1.8;
      Combo.value = Math.min(50, Combo.value + 1);
      addFloatingText(State.w-40, 60, `COMBO x${Combo.value}`, "#a855f7", 0.8, -12);
    }

    function resetCombo(){
      Combo.value = 0; Combo.timer = 0;
    }

    // ---------- Game flow
    function resetAll(){
      zombies.length = 0;
      Player.hp = Player.maxHp;
      Player.score = 0;
      Player.kills = 0;
      Player.misses = 0;

      Player.lastTapShotAt = -1e9;
      Player.turretLastShotAt = -1e9;
      Player.coins = Save.coinsBank;
      recalcFromLevels();
      Combo.value = 0; Combo.timer = 0;
      State.invulnUntil = 0;
      State.hpSmooth = Player.hp;
      State.hpGhost = Player.hp;
      vignette.style.opacity = "0";

      Wave.num = 0;
      Wave.active = false;
      Wave.toSpawn = 0;
      Wave.spawned = 0;
      Wave.spawnEveryMs = 650;
      Wave.nextSpawnAt = 0;
      Wave.clearedAt = 0;

      State.shakeT = 0;
      State.shakeMag = 0;
      State.damageFlash = 0;

      // clear decals quickly
      decal.count = 0;

      // clear particle lifetimes (cheap)
      for (let i=0;i<P_MAX;i++) P.life[i] = 0;
      for (let i=0;i<SHOT_MAX;i++) Shots.life[i] = 0;
    }

    function startGame(){
      resetAll();
      Save.runs = (Save.runs||0)+1;
      persistSave();
      State.mode = "playing";
      State.paused = false;
      mainOverlay.classList.add("hidden");
      shopOverlay.classList.add("hidden");
      continueOverlay.classList.add("hidden");
      pauseOverlay.classList.add("hidden");
      startNextWave();
      updateHUD();
    }

    function revivePrice(){
      return Math.max(50, 100 + Wave.num * 20);
    }

    function revivePlayer(){
      const cost = revivePrice();
      if (!spendCoins(cost)) return showToast("Not enough bank");
      Player.hp = Math.floor(Player.maxHp * 0.5);
      State.invulnUntil = nowMs() + 1500;
      zombies.length = 0;
      Wave.spawned = 0;
      Wave.active = true;
      Wave.toSpawn = Math.max(3, Math.floor(Wave.toSpawn * 0.7));
      Wave.nextSpawnAt = nowMs() + 450;
      continueOverlay.classList.add("hidden");
      State.mode = "playing";
      updateHUD();
    }

    function gameOver(){
      State.mode = "gameover";
      Wave.active = false;
      Save.bestWave = Math.max(Save.bestWave || 0, Wave.num);
      Save.bestScore = Math.max(Save.bestScore || 0, Player.score);
      persistSave();
      updateBestLabels();

      summaryWave.textContent = Wave.num;
      summaryScore.textContent = Player.score;
      summaryKills.textContent = Player.kills;
      summaryBest.textContent = `Wave ${Save.bestWave} ¬∑ Score ${Save.bestScore}`;
      summaryBank.textContent = Player.coins;
      const reviveCost = revivePrice();
      summarySubtitle.textContent = `Revive for ${reviveCost} banked coins or restart from wave 1.`;
      reviveBtn.textContent = `Continue (Revive -${reviveCost})`;
      continueOverlay.classList.remove("hidden");
      mainOverlay.classList.add("hidden");
    }

    function startNextWave(){
      Wave.num++;
      Wave.active = true;

      const w = Wave.num;
      Wave.toSpawn = Math.floor(5 + w * 2.6);
      Wave.spawned = 0;

      // Faster spawn at higher waves
      Wave.spawnEveryMs = clamp(760 - w * 20, 260, 760);
      Wave.nextSpawnAt = nowMs() + 350;

      // Reward a tiny ‚Äúbreather‚Äù after shop
      Sound.play("wave");
      updateHUD();
    }

    function waveCleared(){
      Wave.active = false;
      Wave.clearedAt = nowMs();
      State.mode = "shop";
      if (Wave.num > (Save.bestWave||0)) { Save.bestWave = Wave.num; persistSave(); updateBestLabels(); }
      openShop();
    }

    function openShop(){
      updateShopUI();
      shopOverlay.classList.remove("hidden");
    }

    function closeShopAndStartWave(){
      shopOverlay.classList.add("hidden");
      State.mode = "playing";
      startNextWave();
    }

    function updateShopUI(){
      costDmg.textContent = `Cost: ${costDamage()} coins`;
      costRate.textContent = `Cost: ${costRateUp()} coins`;
      costTurret.textContent = Player.turretLevel === 0 ? `Cost: ${costTurretUp()} (install)` : `Cost: ${costTurretUp()} coins`;

      buyDmg.disabled = Player.coins < costDamage();
      buyRate.disabled = Player.coins < costRateUp();
      buyTurret.disabled = Player.coins < costTurretUp();

      buyDmg.style.opacity = buyDmg.disabled ? 0.55 : 1;
      buyRate.style.opacity = buyRate.disabled ? 0.55 : 1;
      buyTurret.style.opacity = buyTurret.disabled ? 0.55 : 1;

      dmgDesc.textContent = `+1 tap dmg (Lv ${Player.dmgLevel})`;
      rateDesc.textContent = `Shoot ${(1000/Player.tapCooldownMs).toFixed(1)}/s ‚Üí ${(1000/Math.max(80, Player.tapCooldownMs*0.9)).toFixed(1)}/s`;
      const nextTurretCd = clamp(Player.turretCooldownMs * 0.92, 240, 900);
      turretDesc.textContent = Player.turretLevel === 0 ? "Install an auto turret" : `Fire ${(1000/Player.turretCooldownMs).toFixed(1)}/s ‚Üí ${(1000/nextTurretCd).toFixed(1)}/s`;

      const ratePerSec = (1000 / Player.tapCooldownMs).toFixed(1);
      const turretTxt = Player.turretLevel === 0 ? "none" : `Lv ${Player.turretLevel}`;
      shopStats.textContent =
        `Bank ${Player.coins} ¬∑ Tap dmg ${Player.tapDamage} ¬∑ Fire ${ratePerSec}/s ¬∑ Turret ${turretTxt}`;
      updateHUD();
    }

    // ---------- Spawning zombies (wave-based difficulty + types)
    function chooseZombieType(waveNum){
      // More runners and tanks later
      const runnerChance = clamp(0.18 + waveNum * 0.010, 0.18, 0.48);
      const tankChance   = clamp(0.06 + waveNum * 0.008, 0.06, 0.26);
      const r = Math.random();
      if (r < tankChance) return "tank";
      if (r < tankChance + runnerChance) return "runner";
      return "normal";
    }

    function spawnZombie(){
      let typeKey = chooseZombieType(Wave.num);
      const isElite = (Wave.num > 0 && Wave.num % 5 === 0 && Wave.spawned === 0);
      if (isElite) typeKey = "tank";
      const base = ZOMBIE_TYPES[typeKey];

      const speedScale = 1 + Wave.num * 0.040;  // slightly faster each wave
      const hpScale    = (1 + Wave.num * (typeKey === "tank" ? 0.12 : 0.09)) * (isElite ? 1.65 : 1);

      const margin = 26;
      const x = rand(margin, State.w - margin);
      const y = rand(State.playTop + 10, State.playTop + 50);
      const z = {
        type: typeKey,
        x, y,
        vy: base.speed * speedScale,
        r: base.r,
        maxHp: Math.ceil(base.hp * hpScale),
        hp: 0,
        coin: base.coin + Math.floor(Wave.num * 0.25) + (isElite ? 12 : 0),
        passDmg: base.passDmg + Math.floor(Wave.num * 0.12) + (isElite ? 8 : 0),
        elite: isElite,

        // animation
        t: rand(0, 10),
        bob: 0,
        step: rand(0, Math.PI*2),
        hitT: 0,

        // sprite frame timer
        frame: 0,
        frameT: 0,
      };
      z.hp = z.maxHp;
      zombies.push(z);
    }

    // ---------- Turret logic
    function turretDamage(){
      if (Player.turretLevel <= 0) return 0;
      // Turret damage scales gently
      return 1 + Math.floor(Player.turretLevel * 0.85);
    }

    function turretTryShoot(){
      if (Player.turretLevel <= 0) return;
      const t = nowMs();
      if (t - Player.turretLastShotAt < Player.turretCooldownMs) return;
      if (zombies.length === 0) return;

      // Nearest zombie (simple O(n) is fine for ~60)
      const tx = State.w * 0.5;
      const ty = State.h - 18;

      let best = -1;
      let bestD2 = 1e18;
      for (let i=0;i<zombies.length;i++){
        const z = zombies[i];
        const dx = z.x - tx;
        const dy = z.y - ty;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2){
          bestD2 = d2;
          best = i;
        }
      }
      if (best === -1) return;

      Player.turretLastShotAt = t;

      const z = zombies[best];
      const dmg = turretDamage();

      spawnShot(tx, ty, z.x, z.y, 0.09);

      // impact
      z.hp -= dmg;
      z.hitT = 0.10;
      spawnParticles(z.x, z.y, 8, 120);
      addRing(z.x, z.y, 10, 0.2);
      Sound.play("hit");

      if (z.hp <= 0) {
        Sound.play("kill");
        onZombieKilled(best);
      }
    }

    // ---------- HUD updates
    function updateHUD(){
      hpLabel.textContent = fmt(Player.hp);
      const pct = clamp(Player.hp / Player.maxHp, 0, 1);
      const pctSmooth = clamp(State.hpSmooth / Player.maxHp, 0, 1);
      const pctGhost = clamp(State.hpGhost / Player.maxHp, 0, 1);
      hpFill.style.transform = `scaleX(${pctSmooth})`;
      hpGhost.style.transform = `scaleX(${pctGhost})`;
      hpPct.textContent = `${fmt(pct*100)}%`;
      hpFill.style.background = pct < 0.25 ? "linear-gradient(90deg, rgba(239,68,68,.95), rgba(248,113,113,.65))" : pct < 0.5 ? "linear-gradient(90deg, rgba(245,158,11,.95), rgba(251,191,36,.65))" : "linear-gradient(90deg, rgba(34,197,94,.95), rgba(34,197,94,.55))";
      vignette.style.opacity = pct < 0.35 ? lerp(0.2, 0.55, 1-pct) : "0";

      coinLabel.textContent = fmt(Player.coins);
      waveLabel.textContent = fmt(Wave.num);
      scoreLabel.textContent = fmt(Player.score);

      dmgLabel.textContent = `${fmt(Player.tapDamage)} (Lv ${Player.dmgLevel})`;
      rateLabel.textContent = `${(1000/Player.tapCooldownMs).toFixed(1)}/s (Lv ${Player.rateLevel})`;
      turretLabel.textContent = Player.turretLevel ? `Lv ${Player.turretLevel}` : "‚Äî";

      const totalWave = Math.max(Wave.toSpawn, 1);
      const remaining = zombies.length + Math.max(0, Wave.toSpawn - Wave.spawned);
      const progress = clamp(1 - (remaining / totalWave), 0, 1);
      waveFillEl.style.width = `${progress*100}%`;
      waveProgressLabel.textContent = `${Math.max(0, totalWave-remaining)}/${totalWave}`;
    }

    // ---------- Rendering helpers
    function drawRoundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function drawZombieProcedural(z){
      // A simple animated ‚Äúwalking‚Äù zombie: head + body + swinging legs + bob
      const x = z.x;
      const y = z.y - z.bob;
      const s = 1 + (z.hitT > 0 ? 0.06 : 0); // tiny hit pop
      const r = z.r * s;

      // Colors by type (subtle)
      const isRunner = z.type === "runner";
      const isTank   = z.type === "tank";
      const skin = isTank ? "rgba(140, 190, 120, 0.95)" : isRunner ? "rgba(125, 200, 145, 0.95)" : "rgba(120, 190, 135, 0.95)";
      const cloth= isTank ? "rgba(60, 80, 92, 0.95)" : isRunner ? "rgba(70, 86, 105, 0.95)" : "rgba(68, 84, 100, 0.95)";
      const dark = "rgba(10,12,16,.65)";
      const outline = z.hitT > 0 ? "rgba(255,255,255,.28)" : "rgba(0,0,0,.35)";

      ctx.save();
      ctx.translate(x, y);

      // shadow
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.beginPath();
      ctx.ellipse(0, r*1.25, r*0.9, r*0.35, 0, 0, Math.PI*2);
      ctx.fill();

      if (z.elite) {
        ctx.strokeStyle = "rgba(250,204,21,.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, r*1.15, 0, Math.PI*2);
        ctx.stroke();
      }

      // legs swing
      const swing = Math.sin(z.step) * (isTank ? 0.22 : isRunner ? 0.55 : 0.38);
      const legY = r*1.10;
      const legLen = r*0.9;

      ctx.lineCap = "round";
      ctx.lineWidth = Math.max(2, r*0.16);
      ctx.strokeStyle = "rgba(30,35,45,.95)";

      ctx.beginPath();
      ctx.moveTo(-r*0.25, legY);
      ctx.lineTo(-r*0.25 + swing*r*0.32, legY + legLen);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r*0.25, legY);
      ctx.lineTo(r*0.25 - swing*r*0.32, legY + legLen);
      ctx.stroke();

      // body
      ctx.fillStyle = cloth;
      ctx.strokeStyle = outline;
      ctx.lineWidth = Math.max(1.5, r*0.08);
      drawRoundedRect(-r*0.62, -r*0.10, r*1.24, r*1.25, r*0.35);
      ctx.fill();
      ctx.stroke();

      // arms
      ctx.strokeStyle = "rgba(35,45,55,.9)";
      ctx.lineWidth = Math.max(2, r*0.12);
      ctx.beginPath();
      ctx.moveTo(-r*0.62, r*0.35);
      ctx.lineTo(-r*0.98, r*0.55 + swing*r*0.15);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(r*0.62, r*0.35);
      ctx.lineTo(r*0.98, r*0.55 - swing*r*0.15);
      ctx.stroke();

      // head
      ctx.fillStyle = skin;
      ctx.strokeStyle = outline;
      ctx.lineWidth = Math.max(1.2, r*0.08);
      ctx.beginPath();
      ctx.arc(0, -r*0.70, r*0.55, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // eyes + mouth
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.beginPath();
      ctx.arc(-r*0.18, -r*0.78, r*0.08, 0, Math.PI*2);
      ctx.arc(r*0.18, -r*0.78, r*0.08, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = dark;
      ctx.lineWidth = Math.max(1, r*0.06);
      ctx.beginPath();
      ctx.arc(0, -r*0.58, r*0.18, 0.1*Math.PI, 0.9*Math.PI);
      ctx.stroke();

      // HP bar (only if damaged)
      if (z.hp < z.maxHp) {
        const bw = r*1.3;
        const bh = Math.max(4, r*0.18);
        const px = -bw/2;
        const py = -r*1.42;
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(px, py, bw, bh);
        const t = clamp(z.hp / z.maxHp, 0, 1);
        ctx.fillStyle = t > 0.5 ? "rgba(34,197,94,.9)" : t > 0.25 ? "rgba(245,158,11,.9)" : "rgba(239,68,68,.9)";
        ctx.fillRect(px, py, bw * t, bh);
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.strokeRect(px, py, bw, bh);
      }

      ctx.restore();
    }

    function drawZombieSprite(z){
      const img = Assets.zombieSheet;
      if (!img) return false;

      // Assume 4 frames horizontally, single row
      const frames = 4;
      const fw = img.width / frames;
      const fh = img.height;

      const x = z.x;
      const y = z.y - z.bob;

      // animate
      z.frameT += 1/60; // approximate, will also update in update()
      const f = z.frame % frames;

      const scale = (z.type === "tank") ? 1.25 : (z.type === "runner") ? 0.95 : 1.05;
      const size = z.r * 2.2 * scale;

      ctx.save();
      ctx.translate(x, y);
      const hitS = (z.hitT > 0) ? 1.08 : 1.0;
      ctx.scale(hitS, hitS);

      // shadow
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.beginPath();
      ctx.ellipse(0, z.r*1.3, z.r*0.95, z.r*0.38, 0, 0, Math.PI*2);
      ctx.fill();

      if (z.elite) {
        ctx.strokeStyle = "rgba(250,204,21,.85)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.2, 0, Math.PI*2);
        ctx.stroke();
      }

      // image
      ctx.globalAlpha = 0.98;
      ctx.drawImage(img, f*fw, 0, fw, fh, -size/2, -size/2, size, size);

      // outline on hit
      if (z.hitT > 0) {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(255,255,255,.28)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, z.r*1.05, 0, Math.PI*2);
        ctx.stroke();
      }

      // HP bar
      if (z.hp < z.maxHp) {
        const bw = z.r*1.35;
        const bh = Math.max(4, z.r*0.18);
        const px = -bw/2;
        const py = -z.r*1.45;
        ctx.globalAlpha = 1;
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(px, py, bw, bh);
        const t = clamp(z.hp / z.maxHp, 0, 1);
        ctx.fillStyle = t > 0.5 ? "rgba(34,197,94,.9)" : t > 0.25 ? "rgba(245,158,11,.9)" : "rgba(239,68,68,.9)";
        ctx.fillRect(px, py, bw*t, bh);
        ctx.strokeStyle = "rgba(255,255,255,.12)";
        ctx.strokeRect(px, py, bw, bh);
      }

      ctx.restore();
      return true;
    }

    function drawTurret(){
      if (Player.turretLevel <= 0) return;
      const x = State.w * 0.5;
      const y = State.h - 16;

      ctx.save();
      ctx.translate(x,y);

      // base
      ctx.fillStyle = "rgba(20,24,34,.92)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      drawRoundedRect(-24, -14, 48, 22, 10);
      ctx.fill(); ctx.stroke();

      // barrel
      ctx.fillStyle = "rgba(139,92,246,.85)";
      ctx.strokeStyle = "rgba(139,92,246,.35)";
      drawRoundedRect(-6, -26, 12, 18, 6);
      ctx.fill(); ctx.stroke();

      // glow
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "rgba(139,92,246,1)";
      ctx.beginPath();
      ctx.arc(0, -18, 10 + Player.turretLevel*1.2, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // ---------- Main update loop
    function update(dt){
      State.time += dt;

      // screen shake decay
      if (State.shakeT > 0) State.shakeT = Math.max(0, State.shakeT - dt);
      if (State.damageFlash > 0) State.damageFlash = Math.max(0, State.damageFlash - dt);

      if (State.hitStop > 0){
        State.hitStop = Math.max(0, State.hitStop - dt);
        return;
      }

      State.hpSmooth = lerp(State.hpSmooth, Player.hp, dt * 8);
      State.hpGhost = lerp(State.hpGhost, Player.hp, dt * 2.5);
      if (Combo.timer > 0){
        Combo.timer -= dt;
        if (Combo.timer <= 0) resetCombo();
      }

      if (State.mode !== "playing") { updateHUD(); return; }
      if (State.paused) return;

      if (pointerDown) {
        if (zombies.length) tryShootAt(pointerPos.x, pointerPos.y);
      }

      // Spawn logic
      const t = nowMs();
      if (Wave.active && Wave.spawned < Wave.toSpawn && t >= Wave.nextSpawnAt) {
        spawnZombie();
        Wave.spawned++;
        Wave.nextSpawnAt = t + Wave.spawnEveryMs * rand(0.72, 1.10);
      }

      // Turret
      turretTryShoot();

      // Update zombies
      for (let i=zombies.length-1; i>=0; i--){
        const z = zombies[i];
        z.t += dt;

        // bob + step
        const bobAmp = (z.type === "runner") ? 4.6 : (z.type === "tank") ? 2.9 : 3.6;
        z.step += dt * ((z.type === "runner") ? 10.0 : (z.type === "tank") ? 6.2 : 8.0);
        z.bob = Math.sin(z.t*8.2) * bobAmp;

        z.y += z.vy * dt;
        if (z.y < State.playTop) z.y = State.playTop;

        if (z.hitT > 0) z.hitT = Math.max(0, z.hitT - dt);

        // sprite animation frame (if sheet exists)
        if (Assets.zombieSheetOk) {
          z.frameT += dt;
          const spd = (z.type === "runner") ? 0.09 : (z.type === "tank") ? 0.14 : 0.11;
          if (z.frameT >= spd) {
            z.frameT = 0;
            z.frame = (z.frame + 1) & 3;
          }
        }

        // Reached bottom: damage player and remove
        if (z.y - z.r > State.h + 6) {
          applyPlayerDamage(z.passDmg);
          // Remove zombie
          const last = zombies.length - 1;
          zombies[i] = zombies[last];
          zombies.pop();
        }
      }

      // Wave complete?
      if (Wave.active && Wave.spawned >= Wave.toSpawn && zombies.length === 0) {
        waveCleared();
      }

      updateHUD();
    }

    function updateParticles(dt){
      // Particles
      for (let i=0;i<P_MAX;i++){
        let life = P.life[i];
        if (life <= 0) continue;
        life -= dt;
        P.life[i] = life;
        if (life <= 0) continue;

        P.vy[i] += 520 * dt; // gravity
        P.x[i]  += P.vx[i] * dt;
        P.y[i]  += P.vy[i] * dt;

        // mild drag
        P.vx[i] *= (1 - 0.8*dt);
        P.vy[i] *= (1 - 0.3*dt);
      }

      // Decals (fade)
      for (let i=0;i<decal.count;i++){
        if (decal.life[i] <= 0) continue;
        decal.life[i] -= dt;
      }

      // Shots
      for (let i=0;i<SHOT_MAX;i++){
        if (Shots.life[i] <= 0) continue;
        Shots.life[i] -= dt;
      }

      // Floating text
      for (let i=0;i<FT_MAX;i++){
        const ft = FT[i];
        if (ft.life <= 0) continue;
        ft.life -= dt;
        ft.y += ft.vy * dt;
      }

      // Rings
      for (let i=0;i<R_MAX;i++){
        if (Rings.life[i] <= 0) continue;
        Rings.life[i] -= dt;
      }

      // Reticles
      for (let i=0;i<RET_MAX;i++){
        if (Ret.life[i] <= 0) continue;
        Ret.life[i] -= dt;
      }
    }

    // ---------- Drawing
    function draw(){
      // Clear
      ctx.clearRect(0,0,State.w,State.h);

      // Screen shake transform
      ctx.save();
      if (State.shakeT > 0) {
        const t = State.shakeT;
        const mag = State.shakeMag * (t/0.18);
        ctx.translate(rand(-mag, mag), rand(-mag, mag));
      }

      // Subtle ground line near bottom
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, State.h - 8);
      ctx.lineTo(State.w, State.h - 8);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Blood decals (if image present)
      if (Assets.bloodOk && decal.count > 0) {
        for (let i=0;i<decal.count;i++){
          const life = decal.life[i];
          if (life <= 0) continue;
          const t = clamp(life / decal.max[i], 0, 1);
          const a = decal.a[i] * t;
          const size = lerp(44, 56, 1 - t);
          const cell = decal.cell[i] || 0;
          const atlas = Assets.bloodAtlas;
          const sx = (cell % atlas.cols) * atlas.cellW;
          const sy = Math.floor(cell / atlas.cols) * atlas.cellH;

          ctx.save();
          ctx.translate(decal.x[i], decal.y[i]);
          ctx.rotate(decal.rot[i]);
          ctx.globalAlpha = a;
          ctx.drawImage(Assets.blood, sx, sy, atlas.cellW, atlas.cellH, -size/2, -size/2, size, size);
          ctx.restore();
        }
      }

      // Turret
      drawTurret();

      // Zombies
      for (let i=0;i<zombies.length;i++){
        const z = zombies[i];
        if (Assets.zombieSheetOk) {
          // Use sprite if possible, else fallback procedural
          const ok = drawZombieSprite(z);
          if (!ok) drawZombieProcedural(z);
        } else {
          drawZombieProcedural(z);
        }
      }

      // Shots
      for (let i=0;i<SHOT_MAX;i++){
        const life = Shots.life[i];
        if (life <= 0) continue;
        const tLife = clamp(life / Shots.max[i], 0, 1);
        const t = 1 - tLife;
        const x1 = Shots.x1[i], y1 = Shots.y1[i];
        const x2 = Shots.x2[i], y2 = Shots.y2[i];
        const px = lerp(x1, x2, t);
        const py = lerp(y1, y2, t);

        ctx.globalAlpha = tLife * 0.7;
        ctx.strokeStyle = "rgba(139,92,246,.85)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // moving projectile dot
        ctx.globalAlpha = clamp(0.35 + (1 - tLife)*0.65, 0, 1);
        ctx.fillStyle = "rgba(255,255,255,.95)";
        ctx.beginPath();
        ctx.arc(px, py, 2.6, 0, Math.PI*2);
        ctx.fill();

        // muzzle flash
        const flash = Math.max(0, 0.5 - t*2.2);
        if (flash > 0) {
          ctx.globalAlpha = flash * 0.65;
          ctx.fillStyle = "rgba(255,255,255,.9)";
          ctx.beginPath();
          ctx.arc(x1, y1, 6 + flash*6, 0, Math.PI*2);
          ctx.fill();
        }

        // tiny impact shimmer
        ctx.globalAlpha = Math.max(0, (1 - t) * 0.4);
        ctx.strokeStyle = "rgba(255,255,255,.55)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.arc(x2, y2, 6 + (1-tLife)*4, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Particles
      for (let i=0;i<P_MAX;i++){
        const life = P.life[i];
        if (life <= 0) continue;
        const t = clamp(life / P.max[i], 0, 1);
        const a = t * 0.9;

        ctx.globalAlpha = a;
        // HSL without expensive strings? (strings are fine at this scale, but we keep it simple)
        const hue = P.hue[i];
        ctx.fillStyle = `hsla(${hue}, 90%, 55%, ${a})`;

        const s = P.size[i];
        ctx.beginPath();
        ctx.arc(P.x[i], P.y[i], s, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Rings
      for (let i=0;i<R_MAX;i++){
        const life = Rings.life[i];
        if (life <= 0) continue;
        const t = clamp(life / Rings.max[i], 0, 1);
        ctx.globalAlpha = t*0.5;
        ctx.strokeStyle = `rgba(255,255,255,${0.6*t})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(Rings.x[i], Rings.y[i], Rings.r[i]*(1+(1-t)*1.4), 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Tap reticles
      for (let i=0;i<RET_MAX;i++){
        const life = Ret.life[i];
        if (life <= 0) continue;
        const t = clamp(life / Ret.max[i], 0, 1);
        ctx.globalAlpha = t*0.6;
        ctx.strokeStyle = "rgba(139,92,246,.7)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(Ret.x[i], Ret.y[i], 18*(1-t), 0, Math.PI*2);
        ctx.stroke();
      }

      // Floating text
      ctx.font = "700 14px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      for (let i=0;i<FT_MAX;i++){
        const ft = FT[i];
        if (ft.life <= 0) continue;
        const t = clamp(ft.life / ft.max, 0, 1);
        ctx.globalAlpha = t;
        ctx.fillStyle = ft.color;
        ctx.fillText(ft.text, ft.x, ft.y);
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      // Damage flash overlay (no transform)
      if (State.damageFlash > 0) {
        const a = clamp(State.damageFlash / 0.22, 0, 1) * 0.25;
        ctx.fillStyle = `rgba(239,68,68,${a})`;
        ctx.fillRect(0,0,State.w,State.h);
      }

      // Start hint while in start mode (canvas-only hint behind overlay is fine)
      if (State.mode === "playing") {
        // small bottom hint if no turret yet (only early waves)
        if (Wave.num <= 2 && Player.turretLevel === 0) {
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = "rgba(255,255,255,.9)";
          ctx.font = "700 12px ui-sans-serif, system-ui";
          ctx.textAlign = "center";
          ctx.fillText("Tip: Buy a turret between waves üõí", State.w/2, State.h - 36);
          ctx.globalAlpha = 1;
        }
      }
    }

    // ---------- Loop
    function loop(){
      const t = nowMs();
      const dt = clamp((t - State.lastT) / 1000, 0, 0.033);
      State.lastT = t;

      update(dt);
      updateParticles(dt);
      draw();

      requestAnimationFrame(loop);
    }

    // ---------- Start / Shop UI setup text
    function setStartOverlay(){
      overlayTitle.textContent = "Tap to start";
      overlayDesc.innerHTML = `Your first tap will also unlock audio on mobile. Survive as many waves as you can.<br>Banked coins: <b>${Save.coinsBank}</b> ¬∑ Upgrades: dmg ${Save.dmgLevel}, rate ${Save.rateLevel}, turret ${Save.turretLevel}`;
      startBtn.textContent = "Start";
      mainOverlay.classList.remove("hidden");
      shopOverlay.classList.add("hidden");
      State.mode = "start";
    }

    // ---------- Passive ‚Äúenter shop‚Äù helper (when wave clears)
    function closeIfOpen(el){
      if (!el.classList.contains("hidden")) el.classList.add("hidden");
    }

    // ---------- Initialize
    function init(){
      resize();
      setStartOverlay();
      updateHUD();
      updateSettingsUI();

      // Keep canvas properly sized
      // (call once more after layout settles)
      setTimeout(resize, 50);

      requestAnimationFrame(loop);
    }

    init();
  })();
  </script>
</body>
</html>
